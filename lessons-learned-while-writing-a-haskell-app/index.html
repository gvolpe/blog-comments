<!DOCTYPE html> <html lang="en-uk"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> Lessons learned while writing a Haskell application &bull; gvolpe's blog </title> <meta name="description" content="Having introduced Haskell at my last job I wanted to put into practice all the stuff I learned: take the good, leave the bad. So I started working on an exch..."> <link rel="stylesheet" href="/blog/css/main.css"> <link rel="canonical" href="https://gvolpe.github.io/blog/lessons-learned-while-writing-a-haskell-app/"> <link rel="alternate" type="application/rss+xml" title="gvolpe's blog" href="https://gvolpe.github.io/blog/feed.xml" /> <script defer type="text/javascript" src="https://api.pirsch.io/pirsch.js" id="pirschjs" data-code="db2twsz97grcqToSsEMhvcQXm8rLaFmQ"> </script> </head> <body class="single"> <main class="main"> <header class="header"> <div class="overlay"> <div class="container"> <h1 class="title"> <a href="/blog/">gvolpe's blog</a> </h1> <nav class="navbar"> <a href="#" class="menu-icon"> <span></span> <span></span> <span></span> </a> <ul class="nav"> <li><a href="https://gvolpe.com" target="_blank">Website</a></li> </ul> </nav> </div> </div> </header> <article class="post container card"> <header class="post-header"> <h1 class="post-title">Lessons learned while writing a Haskell application</h1> <span class="post-meta"> <time class="post-date" datetime="2019-06-23">Jun 23, 2019</time> <span class="post-author">by Gabriel Volpe</span> </span> </header> <div class="post-content"> <p>Having introduced Haskell at my last job I wanted to put into practice all the stuff I learned: take the good, leave the bad. So I started working on an <a href="https://github.com/gvolpe/exchange-rates">exchange rates API</a> using a few libraries I haven’t used before, exclusively for fun and learning purposes.</p> <p>In this blog post I’ll try to share what I have identified as good practice so far and what are my personal recommendations when writing a Haskell application.</p> <blockquote> <p>Note: if you write Scala, many of the tips will also be useful for you.</p> </blockquote> <h3 id="configuration">Configuration</h3> <p>I tried a couple of libraries where you must write your configuration file using either <code>yaml</code>, <code>hocon</code> or <code>json</code> but I wasn’t satisfied until I’ve been recommended to use <a href="https://dhall-lang.org/">dhall-lang</a>. It’s a configuration language guaranteed to terminate that has also Haskell bindings, <a href="https://hackage.haskell.org/package/dhall">nicely packaged</a> for easy use. It looks as follows:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">let</span> <span class="kt">Env</span> <span class="ow">=</span> <span class="o">&lt;</span> <span class="kt">Test</span> <span class="kt">:</span> <span class="p">{}</span> <span class="o">|</span> <span class="kt">Prod</span> <span class="kt">:</span> <span class="p">{}</span> <span class="o">&gt;</span>

<span class="kr">let</span> <span class="n">makeConfig</span> <span class="ow">=</span> <span class="n">λ</span><span class="p">(</span><span class="n">env</span> <span class="kt">:</span> <span class="kt">Env</span><span class="p">)</span> <span class="ow">-&gt;</span>
  <span class="p">{</span> <span class="n">forex</span> <span class="ow">=</span> <span class="n">makeForexConfig</span> <span class="n">env</span>
  <span class="p">,</span> <span class="n">redis</span> <span class="ow">=</span> <span class="n">makeRedisConfig</span> <span class="n">env</span>
  <span class="p">}</span>

<span class="kr">in</span> <span class="n">makeConfig</span> <span class="p">(</span> <span class="kt">Env</span><span class="o">.</span><span class="kt">Test</span> <span class="p">{</span><span class="ow">=</span><span class="p">}</span> <span class="p">)</span></code></pre></div> <p>Yes, it’s a language so one can define functions! Neat huh?</p> <h3 id="production-ready-effect-rio">Production-ready effect: RIO</h3> <p>Ever since I read Michael Snoyman’s articles <a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">The ReaderT design pattern</a> and <a href="https://www.fpcomplete.com/blog/2017/07/the-rio-monad">The RIO Monad</a> I’ve been convinced that this is the nicest and easiest approach to write applications.</p> <p>Two years later after these articles have been published the package has evolved into what they call <a href="https://hackage.haskell.org/package/rio">RIO: A standard library for Haskell</a>.</p> <p>It doesn’t only package <code>RIO</code>, its monadic effect, but also its own prelude. And in addition, it re-exports a bunch of other goodies such as error handling and lenses functions.</p> <p>So right now this is my effect system of choice and it’s the one you’ll see in the examples below.</p> <blockquote> <p>It’s worth mentioning other (higher-order) effects like <a href="https://github.com/fused-effects/fused-effects">fused-effects</a> and <a href="https://github.com/polysemy-research/polysemy">polysemy</a>, and also <a href="https://github.com/tweag/capability">capability</a>. I think we should all keep an eye on them as they look promising and propose a different take on effects.</p> </blockquote> <h3 id="polymorphic-record-of-functions">Polymorphic record of functions</h3> <p>This is by far the best way I know of defining polymorphic interfaces.</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Cache</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">Cache</span>
  <span class="p">{</span> <span class="n">cacheNewResult</span> <span class="ow">::</span> <span class="kt">Expiration</span> <span class="ow">-&gt;</span> <span class="kt">Currency</span> <span class="ow">-&gt;</span> <span class="kt">Currency</span> <span class="ow">-&gt;</span> <span class="kt">Exchange</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
  <span class="p">,</span> <span class="n">cachedExchange</span> <span class="ow">::</span> <span class="kt">Currency</span> <span class="ow">-&gt;</span> <span class="kt">Currency</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Exchange</span><span class="p">)</span>
  <span class="p">}</span></code></pre></div> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Counter</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">Counter</span>
  <span class="p">{</span> <span class="n">incrCount</span> <span class="ow">::</span> <span class="n">m</span> <span class="nb">()</span>
  <span class="p">,</span> <span class="n">getCount</span> <span class="ow">::</span> <span class="n">m</span> <span class="kt">Int</span>
  <span class="p">,</span> <span class="n">resetCount</span> <span class="ow">::</span> <span class="n">m</span> <span class="nb">()</span>
  <span class="p">}</span></code></pre></div> <p>The advantage is that we can create different interpreters using different effect types. For example, the main implementation of <code>Cache m</code> uses <code>Redis</code> whereas the test one uses an in-memory map stored in an <code>IORef</code>.</p> <h5 id="why-not-typeclasses">Why not typeclasses?</h5> <p>Typeclasses are probably what come first when we think about polymorphic interfaces. However, they need laws / properties that define whether an instance is a valid one or not. Secondly, we can only define a single instance for a specific type. This is called coherence. If we can do that, great! If we fail then we would be better off using a record of functions instead.</p> <p>To further defend this argument I should, perhaps, write another blog post only on this topic showing examples and expanding on the idea.</p> <h3 id="smart-constructors">Smart constructors</h3> <p>In order to create a specific record of functions it is recommended to hide its constructor and instead export a <em>smart constructor</em>. These are plain functions, normally effectful, responsible for the creation of a single interface. For convention, I chose to prefix them with <code>mk</code> (for make).</p> <p>Here’s how I defined the smart constructor for <code>Counter</code>:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">mkCounter</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Counter</span> <span class="kt">IO</span><span class="p">)</span>
<span class="nf">mkCounter</span> <span class="ow">=</span>
  <span class="p">(</span><span class="n">newIORef</span> <span class="mi">0</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">IORef</span> <span class="kt">Int</span><span class="p">))</span>
    <span class="o">&lt;&amp;&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">ref</span> <span class="ow">-&gt;</span> <span class="kt">Counter</span>
          <span class="p">{</span> <span class="n">incrCount</span>  <span class="ow">=</span> <span class="n">void</span> <span class="o">$</span> <span class="n">atomicModifyIORef&#39;</span> <span class="n">ref</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">acc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">acc</span><span class="p">))</span>
          <span class="p">,</span> <span class="n">getCount</span>   <span class="ow">=</span> <span class="n">readIORef</span> <span class="n">ref</span>
          <span class="p">,</span> <span class="n">resetCount</span> <span class="ow">=</span> <span class="n">atomicWriteIORef</span> <span class="n">ref</span> <span class="mi">0</span>
          <span class="p">}</span>
        <span class="p">)</span></code></pre></div> <p>Don’t look so much at the implementation but more at its type signature. This pattern repeats over and over. We’ll see soon how other smart constructors are defined.</p> <h3 id="parametric-reasoning">Parametric reasoning</h3> <p><code>RIO</code> is a concrete effect type, basically a newtype around <code>ReaderT</code> + <code>IO</code>, but it’s also fully compatible with <code>mtl</code> typeclasses. This means that we can write functions that use <code>RIO</code> directly and others that are 100% polymorphic. So…</p> <h4 id="when-to-be-concrete-vs-when-to-be-polymorphic">When to be concrete vs When to be polymorphic?</h4> <p>Here’s my take: Be polymorphic where you have your main logic and be concrete when there’s no logic to test. Let’s look at an example to illustrate this statement better.</p> <h5 id="to-be-concrete">To be concrete</h5> <p>Here are the smart constructors for <code>Cache m</code> and <code>ForexClient m</code>:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">mkRedisCache</span> <span class="ow">::</span> <span class="kt">HasRedisConfig</span> <span class="n">env</span> <span class="ow">=&gt;</span> <span class="kt">RIO</span> <span class="n">env</span> <span class="p">(</span><span class="kt">Cache</span> <span class="kt">IO</span><span class="p">)</span></code></pre></div> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">mkForexClient</span> <span class="ow">::</span> <span class="kt">HasForexConfig</span> <span class="n">env</span> <span class="ow">=&gt;</span> <span class="kt">RIO</span> <span class="n">env</span> <span class="p">(</span><span class="kt">ForexClient</span> <span class="kt">IO</span><span class="p">)</span></code></pre></div> <p>For our main Cache (implemented using <a href="https://hackage.haskell.org/package/hedis">hedis</a>) and the Forex Client (http client using <a href="https://hackage.haskell.org/package/wreq">wreq</a>) I chose to be concrete, using <code>RIO</code> and the <code>Has</code> pattern.</p> <p>Although this pattern is well described in the articles linked at the top, they don’t cover polymorphic records of functions as is the case with <code>Ctx m</code>. So for a quick reference, here’s the <code>HasCache</code> typeclass and its instance for our context.</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">HasCache</span> <span class="n">ctx</span> <span class="n">m</span> <span class="o">|</span> <span class="n">ctx</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">cacheL</span> <span class="ow">::</span> <span class="kt">Lens&#39;</span> <span class="n">ctx</span> <span class="p">(</span><span class="kt">Cache</span> <span class="n">m</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">HasCache</span> <span class="p">(</span><span class="kt">Ctx</span> <span class="n">m</span><span class="p">)</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">cacheL</span> <span class="ow">=</span> <span class="n">lens</span> <span class="n">getCache</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="p">{</span> <span class="n">getCache</span> <span class="ow">=</span> <span class="n">y</span> <span class="p">})</span></code></pre></div> <blockquote> <p>Note: you need to enable <code>FlexibleInstances</code>, <code>MultiParamTypeClasses</code> and <code>FunctionalDependencies</code>. Thanks to <a href="https://www.reddit.com/user/samb961/">/u/samb961</a> for helping me out with this!</p> </blockquote> <p>In both cases they have no logic I’m interested in testing so there’s no motivation to abstract over the effect type. What I want to test is how these components play their role in the main logic as we will see soon.</p> <h5 id="to-be-polymorphic">To be polymorphic</h5> <p>The main logic resides in the implementation of the <code>CachedForex</code> service. By following the flow diagram below you should be able to understand it.</p> <p><img src="../images/api-rates-flow.png" alt="flow-diagram" /></p> <p><em>For the atomic block <code>bracket</code> and <code>finally</code> from <code>Control.Monad.Catch</code> do the trick.</em></p> <p>Now in order to create the service we need a couple of other components: <code>Logger m</code>, <code>Cache m</code>, <code>Counter m</code> and <code>ForexClient m</code>. We’ve seen above the definition of a few of them and for brevity I’ll skip others as they are quite similar.</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">mkExchangeService</span>
  <span class="ow">::</span> <span class="p">(</span> <span class="kt">MonadMask</span> <span class="n">m</span>
     <span class="p">,</span> <span class="kt">HasLogger</span> <span class="n">ctx</span> <span class="n">m</span>
     <span class="p">,</span> <span class="kt">HasCache</span> <span class="n">ctx</span> <span class="n">m</span>
     <span class="p">,</span> <span class="kt">HasCounter</span> <span class="n">ctx</span> <span class="n">m</span>
     <span class="p">,</span> <span class="kt">HasForexClient</span> <span class="n">ctx</span> <span class="n">m</span>
     <span class="p">,</span> <span class="kt">MonadReader</span> <span class="n">ctx</span> <span class="n">r</span>
     <span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="n">r</span> <span class="p">(</span><span class="kt">ExchangeService</span> <span class="n">m</span><span class="p">)</span></code></pre></div> <p>By making it polymorphic we get to choose our effect type and the dependencies needed while at the same type we apply <a href="https://blog.codinghorror.com/the-principle-of-least-power/">the principle of least power</a>. This gives us <em>parametric reasoning</em>. And it’s perfect since we would like to test our logic without having a Redis instance running nor making real http requests to the external web service.</p> <blockquote> <p>One could argue that even if you make it concrete using <code>RIO</code> or <code>IO</code> you can still pass different implementations but we would be more limited to test using such effect and it’ll be harder to reason about our function by just looking at its type signature.</p> </blockquote> <p><strong>Testing our main service</strong></p> <p>In this case it ended up being more practical testing using <code>IO</code> + <code>IORef</code>, given the <code>MonadMask</code> constraint on <code>m</code>. But for demonstration purposes I wrote another version of the test suite using a <a href="https://github.com/gvolpe/exchange-rates/blob/master/test/Rates/CachedForexRST.hs">stack of monad transformers</a> that doesn’t use <code>IO</code>.</p> <p>The testing approach I followed is to create different interpreters for the dependencies of the main service and then run some property tests on it. So we have an in-memory cache, a dummy Forex client that always returns the same response and a logger that doesn’t log.</p> <p>Finally, you need to choose a test library. I went with <a href="https://hackage.haskell.org/package/hedgehog">hedgehog</a>. Its documentation is quite nice and it’s easy to get started with. Eg: below is the definition of the rates test.</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">prop_get_rates</span> <span class="ow">::</span> <span class="kt">Cache</span> <span class="kt">IO</span> <span class="ow">-&gt;</span> <span class="kt">Property</span>
<span class="nf">prop_get_rates</span> <span class="n">cache</span> <span class="ow">=</span> <span class="n">withTests</span> <span class="mi">1000</span> <span class="o">$</span> <span class="n">property</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="n">rph</span>     <span class="ow">&lt;-</span> <span class="n">forAll</span> <span class="o">$</span> <span class="kt">Gen</span><span class="o">.</span><span class="n">int</span> <span class="p">(</span><span class="kt">Range</span><span class="o">.</span><span class="n">linear</span> <span class="mi">0</span> <span class="mi">10</span><span class="p">)</span>
  <span class="n">count</span>   <span class="ow">&lt;-</span> <span class="n">forAll</span> <span class="o">$</span> <span class="kt">Gen</span><span class="o">.</span><span class="n">int</span> <span class="p">(</span><span class="kt">Range</span><span class="o">.</span><span class="n">linear</span> <span class="mi">0</span> <span class="mi">10</span><span class="p">)</span>
  <span class="kr">let</span> <span class="n">ctx</span> <span class="ow">=</span> <span class="kt">Ctx</span> <span class="n">testLogger</span> <span class="n">cache</span> <span class="p">(</span><span class="n">mkTestCounter</span> <span class="n">count</span><span class="p">)</span> <span class="p">(</span><span class="n">mkTestForexClient</span> <span class="n">rph</span><span class="p">)</span>
  <span class="n">service</span> <span class="ow">&lt;-</span> <span class="n">evalIO</span> <span class="o">$</span> <span class="n">runRIO</span> <span class="n">ctx</span> <span class="n">mkExchangeService</span>
  <span class="n">from</span>    <span class="ow">&lt;-</span> <span class="n">forAll</span> <span class="o">$</span> <span class="kt">Gen</span><span class="o">.</span><span class="n">element</span> <span class="n">currencies</span>
  <span class="n">to</span>      <span class="ow">&lt;-</span> <span class="n">forAll</span> <span class="o">$</span> <span class="kt">Gen</span><span class="o">.</span><span class="n">element</span> <span class="n">currencies</span>
  <span class="n">cached</span>  <span class="ow">&lt;-</span> <span class="n">evalIO</span> <span class="o">$</span> <span class="n">cachedExchange</span> <span class="n">cache</span> <span class="n">from</span> <span class="n">to</span>
  <span class="n">evalIO</span> <span class="p">(</span><span class="n">try</span> <span class="p">(</span><span class="n">getRate</span> <span class="n">service</span> <span class="n">from</span> <span class="n">to</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">TryRate</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="kr">case</span>
    <span class="kt">Right</span> <span class="n">rs</span> <span class="ow">-&gt;</span> <span class="n">rs</span> <span class="o">===</span> <span class="n">fromMaybe</span> <span class="p">(</span><span class="kt">Exchange</span> <span class="mf">1.0</span><span class="p">)</span> <span class="n">cached</span>
    <span class="kt">Left</span>  <span class="kr">_</span>  <span class="ow">-&gt;</span> <span class="n">assert</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">rph</span><span class="p">)</span></code></pre></div> <p>If we get a <code>Right rs</code> then we assert that the rate is equals to the one cached or the one returned by the forex client. If we get a <code>Left e</code> instead that means that the API limit has been reached so we assert that the counter is greater or equals than the “requests per hour” value.</p> <h4 id="web-server">Web server</h4> <p>It wouldn’t be fair if I didn’t mention the web server. It is written using <a href="https://haskell-servant.readthedocs.io/en/stable/#">servant</a> and it’s a pleasure to use. It also allows you to generate documentation from the API definition using <a href="https://swagger.io/">swagger</a>.</p> <p>There are only two endpoints so there’s not much to cover but in a nutshell, I decided to organize the code in three different modules as shown below.</p> <h5 id="endpoints">Endpoints</h5> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">RatesAPI</span> <span class="ow">=</span>
       <span class="kt">ApiVersion</span> <span class="kt">:&gt;</span> <span class="s">&quot;rates&quot;</span> <span class="kt">:&gt;</span> <span class="kt">QueryParam</span> <span class="s">&quot;from&quot;</span> <span class="kt">Currency</span> <span class="kt">:&gt;</span> <span class="kt">QueryParam</span> <span class="s">&quot;to&quot;</span> <span class="kt">Currency</span> <span class="kt">:&gt;</span> <span class="kt">Get</span> <span class="n">&#39;</span><span class="p">[</span><span class="kt">JSON</span><span class="p">]</span> <span class="kt">ExchangeResponse</span>
  <span class="kt">:&lt;|&gt;</span> <span class="kt">ApiVersion</span> <span class="kt">:&gt;</span> <span class="s">&quot;currencies&quot;</span> <span class="kt">:&gt;</span> <span class="kt">Get</span> <span class="n">&#39;</span><span class="p">[</span><span class="kt">JSON</span><span class="p">]</span> <span class="p">[</span><span class="kt">Currency</span><span class="p">]</span></code></pre></div> <p><em>Notice how the API is defined at the type level!</em></p> <h5 id="response-handler">Response handler</h5> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">rates</span>
  <span class="ow">::</span> <span class="kt">ExchangeService</span> <span class="kt">IO</span>
  <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Currency</span>
  <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Currency</span>
  <span class="ow">-&gt;</span> <span class="kt">Handler</span> <span class="kt">ExchangeResponse</span>
<span class="nf">rates</span> <span class="n">service</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">from</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">to</span><span class="p">)</span> <span class="ow">=</span> <span class="n">handle</span>
  <span class="p">(</span><span class="nf">\</span><span class="kt">ApiLimitReached</span> <span class="ow">-&gt;</span>
    <span class="n">throwError</span> <span class="o">$</span> <span class="n">err503</span> <span class="p">{</span> <span class="n">errBody</span> <span class="ow">=</span> <span class="s">&quot;Api limit has been reached&quot;</span> <span class="p">}</span>
  <span class="p">)</span>
  <span class="p">(</span><span class="n">liftIO</span> <span class="o">$</span> <span class="n">exchangeToResponse</span> <span class="n">from</span> <span class="n">to</span> <span class="o">&lt;$&gt;</span> <span class="n">getRate</span> <span class="n">service</span> <span class="n">from</span> <span class="n">to</span><span class="p">)</span>
<span class="nf">rates</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">throwError</span> <span class="o">$</span> <span class="n">err400</span> <span class="p">{</span> <span class="n">errBody</span> <span class="ow">=</span> <span class="s">&quot;Invalid currencies&quot;</span> <span class="p">}</span></code></pre></div> <h5 id="data-and-json-instances">Data and json instances</h5> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">ExchangeResponse</span> <span class="ow">=</span> <span class="kt">ExchangeResponse</span>
  <span class="p">{</span> <span class="n">rate</span> <span class="ow">::</span> <span class="kt">Float</span>
  <span class="p">,</span> <span class="n">from</span> <span class="ow">::</span> <span class="kt">Currency</span>
  <span class="p">,</span> <span class="n">to</span> <span class="ow">::</span> <span class="kt">Currency</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">ToJSON</span> <span class="kt">ExchangeResponse</span></code></pre></div> <h3 id="conclusion">Conclusion</h3> <p>These are some of the best practices I know of nowadays. But we all know this is a continuous learning process, it doesn’t end here. Anyway, I hope you can get something out of it!</p> <h5 id="summarizing">Summarizing:</h5> <ul> <li><em>Parametric reasoning matters</em>: ideally we should be able to tell what a function does by just looking at its type signature.</li> <li>Be concrete when there’s no need to complicate things.</li> <li>Polymorphic records of functions are neat.</li> </ul> <p>Have any thoughts or questions? Share it down in the comments!</p> <p>Find the complete source code <a href="https://github.com/gvolpe/exchange-rates">here</a>.</p> <aside class="share"> <span>Share this: </span> <a href="http://twitter.com/share?text=Lessons learned while writing a Haskell application&amp;url=https://gvolpe.github.io/lessons-learned-while-writing-a-haskell-app/&amp;hashtags=scala,haskell,fp&amp;via=volpegabriel87" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;"> <i class="fa fa-twitter-square"></i> </a> </aside> </div> </article> <footer class="footer t-center"> <div class="container"> <div class="social-icons"> <ul class="text-left"> <li><a href="https://twitter.com/volpegabriel87" target="_blank"><i class="fa fa-twitter"></i></a></li> </ul> </div> <small>&copy; 2022 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small> <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small> </div> </footer> </main> </body> </html></body></html>
<!--
// # Zetsu Jekyll theme - https://github.com/nandomoreriame/zetsu/
// by nandomoreira.me
-->
