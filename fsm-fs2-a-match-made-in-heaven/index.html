<!DOCTYPE html> <html lang="en-uk"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> Finite-State Machines + FS2 streams: A match made in heaven &bull; gvolpe's blog </title> <meta name="description" content="As the title says, finite-state machines and Fs2 streams are a match made in heaven! To demonstrate it, I’ll make up a compelling problem to solve and we wil..."> <link rel="stylesheet" href="/blog/css/main.css"> <link rel="canonical" href="https://gvolpe.github.io/blog/fsm-fs2-a-match-made-in-heaven/"> <link rel="alternate" type="application/rss+xml" title="gvolpe's blog" href="https://gvolpe.github.io/blog/feed.xml" /> <script defer type="text/javascript" src="https://api.pirsch.io/pirsch.js" id="pirschjs" data-code="db2twsz97grcqToSsEMhvcQXm8rLaFmQ"> </script> </head> <body class="single"> <main class="main"> <header class="header"> <div class="overlay"> <div class="container"> <h1 class="title"> <a href="/blog/">gvolpe's blog</a> </h1> <nav class="navbar"> <a href="#" class="menu-icon"> <span></span> <span></span> <span></span> </a> <ul class="nav"> <li><a href="https://gvolpe.com" target="_blank">Website</a></li> </ul> </nav> </div> </div> </header> <article class="post container card"> <header class="post-header"> <h1 class="post-title">Finite-State Machines + FS2 streams: A match made in heaven</h1> <span class="post-meta"> <time class="post-date" datetime="2020-12-29">Dec 29, 2020</time> <span class="post-author">by Gabriel Volpe</span> </span> </header> <div class="post-content"> <p>As the title says, finite-state machines and Fs2 streams are a match made in heaven! To demonstrate it, I’ll make up a compelling problem to solve and we will get to the final solution step by step. Here’s a sneak-peek of the solution.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">Ticker</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Tick</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">timerTick</span><span class="k">:</span> <span class="kt">Tick</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Count</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">Tick</span>, <span class="kt">Count</span><span class="o">)]</span>
  <span class="k">def</span> <span class="n">ticks</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Tick</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Engine</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Concurrent:</span> <span class="kt">Parallel:</span> <span class="kt">Time:</span> <span class="kt">Timer</span><span class="o">](</span>
    <span class="n">publish</span><span class="k">:</span> <span class="kt">Summary</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">],</span>
    <span class="n">ticker</span><span class="k">:</span> <span class="kt">Ticker</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">)</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">fsm</span> <span class="k">=</span> <span class="nc">Engine</span><span class="o">.</span><span class="n">fsm</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">ticker</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">run</span><span class="k">:</span> <span class="kt">Pipe</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Event</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">_</span><span class="o">.</span><span class="n">noneTerminate</span>
      <span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">ticks</span><span class="o">)</span>
      <span class="o">.</span><span class="n">evalMapAccumulate</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">PlayerId</span>, <span class="kt">Agg</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">)(</span><span class="n">fsm</span><span class="o">.</span><span class="n">run</span><span class="o">)</span>
      <span class="o">.</span><span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">On</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">out</span> <span class="o">}</span>
      <span class="o">.</span><span class="n">evalMap</span> <span class="o">{</span> <span class="n">m</span> <span class="k">=&gt;</span>
        <span class="n">F</span><span class="o">.</span><span class="n">timestamp</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">ts</span> <span class="k">=&gt;</span>
          <span class="n">m</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">parTraverse_</span> <span class="o">{</span>
            <span class="k">case</span> <span class="o">(</span><span class="n">pid</span><span class="o">,</span> <span class="n">agg</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">publish</span><span class="o">(</span><span class="n">agg</span><span class="o">.</span><span class="n">summary</span><span class="o">(</span><span class="n">pid</span><span class="o">,</span> <span class="n">ts</span><span class="o">))</span>
          <span class="o">}</span>
        <span class="o">}</span>
      <span class="o">}</span>
<span class="o">}</span></code></pre></div> <p>Interested in seeing more? Continue reading or browse the <a href="https://github.com/gvolpe/fsm-streams">source code</a> on your own :)</p> <h3 id="problem">Problem</h3> <p>We have an adventure game called “Streaming Adventures” where a single player is the main star. A new player starts up at level zero and score zero, and it can only win once level 50 has been cleared. This is how we will model the domain in Scala.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Game</span><span class="o">(</span>
  <span class="n">playerId</span><span class="k">:</span> <span class="kt">PlayerId</span><span class="o">,</span> <span class="c1">// UUID</span>
  <span class="n">playerScore</span><span class="k">:</span> <span class="kt">PlayerScore</span><span class="o">,</span> <span class="c1">// Int</span>
  <span class="n">level</span><span class="k">:</span> <span class="kt">Level</span><span class="o">,</span> <span class="c1">// Int</span>
  <span class="n">gems</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">GemType</span>, <span class="kt">Int</span><span class="o">]</span>
<span class="o">)</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Player</span><span class="o">(</span>
  <span class="n">id</span><span class="k">:</span> <span class="kt">PlayerId</span><span class="o">,</span> <span class="c1">// UUID</span>
  <span class="n">highestScore</span><span class="k">:</span> <span class="kt">PlayerScore</span><span class="o">,</span> <span class="c1">// Int</span>
  <span class="n">gems</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">GemType</span>, <span class="kt">Int</span><span class="o">],</span>
  <span class="n">memberSince</span><span class="k">:</span> <span class="kt">Timestamp</span> <span class="c1">// Instant</span>
<span class="o">)</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">GemType</span>
<span class="k">object</span> <span class="nc">GemType</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Diamond</span>  <span class="k">extends</span> <span class="nc">GemType</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Emerald</span>  <span class="k">extends</span> <span class="nc">GemType</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Ruby</span>     <span class="k">extends</span> <span class="nc">GemType</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Sapphire</span> <span class="k">extends</span> <span class="nc">GemType</span>
<span class="o">}</span></code></pre></div> <p><em>NOTE: For conciseness, newtypes such as <code>PlayerId</code> and <code>Level</code> will be omitted on this post but you can find them in the corresponding <a href="https://github.com/gvolpe/fsm-streams">repository</a>.</em></p> <p>The score can be raised by either collecting gems or solving different puzzles along the way, as well as leveling up. We will model it as an event-driven system with three possible events.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Event</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">createdAt</span><span class="k">:</span> <span class="kt">Timestamp</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Event</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">LevelUp</span><span class="o">(</span>
    <span class="n">playerId</span><span class="k">:</span> <span class="kt">PlayerId</span><span class="o">,</span>
    <span class="n">newLevel</span><span class="k">:</span> <span class="kt">Level</span><span class="o">,</span>
    <span class="n">createdAt</span><span class="k">:</span> <span class="kt">Timestamp</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">Event</span>

  <span class="k">case</span> <span class="k">class</span> <span class="nc">PuzzleSolved</span><span class="o">(</span>
    <span class="n">playerId</span><span class="k">:</span> <span class="kt">PlayerId</span><span class="o">,</span>
    <span class="n">puzzleName</span><span class="k">:</span> <span class="kt">PuzzleName</span><span class="o">,</span>
    <span class="n">duration</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">,</span>
    <span class="n">createdAt</span><span class="k">:</span> <span class="kt">Timestamp</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">Event</span>

  <span class="k">case</span> <span class="k">class</span> <span class="nc">GemCollected</span><span class="o">(</span>
    <span class="n">playerId</span><span class="k">:</span> <span class="kt">PlayerId</span><span class="o">,</span>
    <span class="n">gemType</span><span class="k">:</span> <span class="kt">GemType</span><span class="o">,</span>
    <span class="n">createdAt</span><span class="k">:</span> <span class="kt">Timestamp</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">Event</span>
<span class="o">}</span></code></pre></div> <p>Let’s pretend the game’s logic has been completed and the game is already playable. Our job is to calculate both the <strong>player’s score</strong> and to keep track of the amount of <strong>collected gems</strong> (grouped by type) based on the events defined above. Here’s a table showing how many points an event is worth it.</p> <div class="highlight"><pre><code class="language-bash" data-lang="bash">╔══════════════╦════════╗
║    Event     ║ Points ║
╠══════════════╬════════╣
║ GemCollected ║   <span class="m">10</span>   ║
║ PuzzleSolved ║   <span class="m">50</span>   ║
║ LevelUp      ║   <span class="m">100</span>  ║
╚══════════════╩════════╝</code></pre></div> <p>Another important point to consider is that all these requirements are solely for analytics purposes for all players and concurrent games.</p> <h3 id="solution">Solution</h3> <p>We are going to solve it by aggregating all the incoming events, grouped by <code>PlayerId</code>, within a given time window or a certain amount of processed events, and then emit a <code>Summary</code> that will be processed downstream. We could probably solve it by only using a time window, though, by considering the number of processed events, we can limit how much memory we use.</p> <p>As you have seen at the beginning of this post, the solution involves an aggregation datatype and a finite-state machine, so these are the ones we will analyze first.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">evalMapAccumulate</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">PlayerId</span>, <span class="kt">Agg</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">)(</span><span class="n">fsm</span><span class="o">.</span><span class="n">run</span><span class="o">)</span></code></pre></div> <h4 id="aggregation-datatype">Aggregation datatype</h4> <p>Without further ado, here’s the definition of <code>Agg</code>, a simple datatype used for data aggregation.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">monocle.macros._</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Agg</span><span class="o">(</span>
    <span class="n">level</span><span class="k">:</span> <span class="kt">Level</span><span class="o">,</span>
    <span class="n">points</span><span class="k">:</span> <span class="kt">Points</span><span class="o">,</span>
    <span class="n">gems</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">GemType</span>, <span class="kt">Int</span><span class="o">]</span>
<span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">summary</span><span class="o">(</span><span class="n">pid</span><span class="k">:</span> <span class="kt">PlayerId</span><span class="o">,</span> <span class="n">ts</span><span class="k">:</span> <span class="kt">Timestamp</span><span class="o">)</span><span class="k">:</span> <span class="kt">Summary</span> <span class="o">=</span>
    <span class="nc">Summary</span><span class="o">(</span><span class="n">pid</span><span class="o">,</span> <span class="n">level</span><span class="o">,</span> <span class="n">points</span><span class="o">,</span> <span class="n">gems</span><span class="o">,</span> <span class="n">ts</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Agg</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">empty</span> <span class="k">=</span> <span class="nc">Agg</span><span class="o">(</span><span class="nc">Level</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="nc">Points</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>

  <span class="k">val</span> <span class="nc">_Gems</span>   <span class="k">=</span> <span class="nc">GenLens</span><span class="o">[</span><span class="kt">Agg</span><span class="o">](</span><span class="k">_</span><span class="o">.</span><span class="n">gems</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">_Level</span>  <span class="k">=</span> <span class="nc">GenLens</span><span class="o">[</span><span class="kt">Agg</span><span class="o">](</span><span class="k">_</span><span class="o">.</span><span class="n">level</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">_Points</span> <span class="k">=</span> <span class="nc">GenLens</span><span class="o">[</span><span class="kt">Agg</span><span class="o">](</span><span class="k">_</span><span class="o">.</span><span class="n">points</span><span class="o">)</span>
<span class="o">}</span></code></pre></div> <p>It also comes packed with a bunch of useful lenses and convenient functions.</p> <h4 id="finite-state-machine">Finite-state machine</h4> <p>Quoting the <a href="https://en.wikipedia.org/wiki/Finite-state_machine">Wikipedia</a>:</p> <p>“A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the inputs that trigger each transition. Finite-state machines are of two types—deterministic finite-state machines and non-deterministic finite-state machines. A deterministic finite-state machine can be constructed equivalent to any non-deterministic one.”</p> <p>Here’s how we can possibly define it in Scala, which is the implementation we will be using further down.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">FSM</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">S</span>, <span class="kt">I</span>, <span class="kt">O</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="o">(</span><span class="kt">S</span><span class="o">,</span> <span class="kt">I</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[(</span><span class="kt">S</span>, <span class="kt">O</span><span class="o">)])</span></code></pre></div> <p>Breaking it down:</p> <ul> <li><code>F[_]</code>: a higher-kinded type.</li> <li><code>S</code>: the possible states this machine can be in at a given time.</li> <li><code>I</code>: the input type.</li> <li><code>O</code>: the output type.</li> </ul> <p>Finally, the <code>run</code> function represents the <strong>transition</strong> from a given state and input to another state and output, in the context of <code>F</code>. For example, a pure state-machine can be defined using the identity monad.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">cats.Id</span>

<span class="k">object</span> <span class="nc">FSM</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">identity</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">I</span>, <span class="kt">O</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="o">(</span><span class="kt">S</span><span class="o">,</span> <span class="kt">I</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Id</span><span class="o">[(</span><span class="kt">S</span>, <span class="kt">O</span><span class="o">)])</span> <span class="k">=</span> <span class="nc">FSM</span><span class="o">(</span><span class="n">run</span><span class="o">)</span>
<span class="o">}</span></code></pre></div> <p>To solve our problem, we will use a <a href="https://en.wikipedia.org/wiki/Mealy_machine">Mealy State Machine</a>, which is a specific kind of FSM whose output values are determined both by its current state and the current inputs. Finite-state machines hold many other different properties but I’ll leave this great topic for another day. Right now, we have all we need to solve the problem at hand.</p> <p>Let’s see how we can represent all the valid state transitions for our use case by using our <code>FSM</code>.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">Result</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">[</span><span class="kt">PlayerId</span>, <span class="kt">Agg</span><span class="o">],</span> <span class="nc">Tick</span><span class="o">)</span>
<span class="k">type</span> <span class="kt">State</span>  <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">[</span><span class="kt">PlayerId</span>, <span class="kt">Agg</span><span class="o">],</span> <span class="nc">Count</span><span class="o">)</span>

<span class="k">def</span> <span class="n">fsm</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span>
    <span class="n">ticker</span><span class="k">:</span> <span class="kt">Ticker</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">FSM</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">State</span>, <span class="o">(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Event</span><span class="o">]</span>, <span class="kt">Tick</span><span class="o">)</span>, <span class="kt">Result</span><span class="o">]</span> <span class="k">=</span> <span class="nc">FSM</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">((</span><span class="n">m</span><span class="o">,</span> <span class="n">count</span><span class="o">),</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">event</span><span class="o">),</span> <span class="n">tick</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">playerId</span><span class="o">,</span> <span class="n">modifier</span><span class="o">)</span> <span class="k">=</span>
      <span class="n">event</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Event</span><span class="o">.</span><span class="nc">LevelUp</span><span class="o">(</span><span class="n">pid</span><span class="o">,</span> <span class="n">level</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">pid</span> <span class="o">-&gt;</span> <span class="nc">_Points</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">100</span><span class="o">).</span><span class="n">andThen</span><span class="o">(</span><span class="nc">_Level</span><span class="o">.</span><span class="n">set</span><span class="o">(</span><span class="n">level</span><span class="o">))</span>
        <span class="k">case</span> <span class="nc">Event</span><span class="o">.</span><span class="nc">PuzzleSolved</span><span class="o">(</span><span class="n">pid</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">pid</span> <span class="o">-&gt;</span> <span class="nc">_Points</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">50</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Event</span><span class="o">.</span><span class="nc">GemCollected</span><span class="o">(</span><span class="n">pid</span><span class="o">,</span> <span class="n">gemType</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">pid</span> <span class="o">-&gt;</span> <span class="nc">_Points</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">10</span><span class="o">).</span><span class="n">andThen</span> <span class="o">{</span>
            <span class="nc">_Gems</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">updatedWith</span><span class="o">(</span><span class="n">gemType</span><span class="o">)(</span><span class="k">_</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">orElse</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">))))</span>
          <span class="o">}</span>
      <span class="o">}</span>
    <span class="k">val</span> <span class="n">agg</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">playerId</span><span class="o">,</span> <span class="nc">Agg</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">playerId</span><span class="o">,</span> <span class="n">modifier</span><span class="o">(</span><span class="n">agg</span><span class="o">))</span>
    <span class="k">val</span> <span class="n">nst</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">tick</span> <span class="o">===</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">On</span><span class="o">)</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">PlayerId</span>, <span class="kt">Agg</span><span class="o">]</span> <span class="k">else</span> <span class="n">out</span>

    <span class="n">ticker</span><span class="o">.</span><span class="n">merge</span><span class="o">(</span><span class="n">tick</span><span class="o">,</span> <span class="n">count</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">newTick</span><span class="o">,</span> <span class="n">newCount</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="o">(</span><span class="n">nst</span> <span class="o">-&gt;</span> <span class="n">newCount</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">out</span> <span class="o">-&gt;</span> <span class="n">newTick</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="k">case</span> <span class="o">((</span><span class="n">m</span><span class="o">,</span> <span class="k">_</span><span class="o">),</span> <span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">((</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">On</span><span class="o">))</span>
<span class="o">}</span></code></pre></div> <p>Focus on the state transitions. In the first case, we get <code>Some(event)</code> and then proceed to pattern-match on the <code>Event</code>. We increase the points accordingly, and in specific cases, we modify some other properties. Lastly, we emit the new state and ouput. You can ignore the <code>ticker.merge</code> part for now, only know that it’s managing the ticks either by time-window or a certain number of processed events. We will get into the <code>Ticker</code> implementation soon.</p> <p>The last case requires a bit more of explanation. Because the input type of our FSM is <code>(Option[Event], Tick)</code>, we need to consider the <code>None</code> case, which means our input data has come to an end in a streaming context (more on this soon).</p> <p>A great property of finite-state machines is that they contain pure logic and can be tested in isolation. So let’s do that first before moving on.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">test</span><span class="o">(</span><span class="s">&quot;FSM specification&quot;</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">forAll</span><span class="o">(</span><span class="n">genGemCollected</span><span class="o">,</span> <span class="n">genPuzzleSolved</span><span class="o">,</span> <span class="n">genLevelUp</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">,</span> <span class="n">e3</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">st1</span> <span class="k">@</span> <span class="o">(</span><span class="n">res1</span><span class="o">,</span> <span class="n">count1</span><span class="o">),</span> <span class="o">(</span><span class="n">out1</span><span class="o">,</span> <span class="n">tick1</span><span class="o">))</span> <span class="k">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">run</span><span class="o">((</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span><span class="o">))</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">count1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">tick1</span><span class="o">,</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">out1</span><span class="o">,</span> <span class="n">res1</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">gems</span><span class="o">(</span><span class="n">res1</span><span class="o">),</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">level</span><span class="o">(</span><span class="n">res1</span><span class="o">),</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">points</span><span class="o">(</span><span class="n">res1</span><span class="o">),</span> <span class="mi">10</span><span class="o">)</span>

    <span class="k">val</span> <span class="o">(</span><span class="n">st2</span> <span class="k">@</span> <span class="o">(</span><span class="n">res2</span><span class="o">,</span> <span class="n">count2</span><span class="o">),</span> <span class="o">(</span><span class="n">out2</span><span class="o">,</span> <span class="n">tick2</span><span class="o">))</span> <span class="k">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">st1</span><span class="o">,</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span><span class="o">))</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">count2</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">tick2</span><span class="o">,</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">out2</span><span class="o">,</span> <span class="n">res2</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">gems</span><span class="o">(</span><span class="n">res2</span><span class="o">),</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">level</span><span class="o">(</span><span class="n">res2</span><span class="o">),</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">points</span><span class="o">(</span><span class="n">res2</span><span class="o">),</span> <span class="mi">60</span><span class="o">)</span>

    <span class="k">val</span> <span class="o">(</span><span class="n">st3</span> <span class="k">@</span> <span class="o">(</span><span class="n">res3</span><span class="o">,</span> <span class="n">count3</span><span class="o">),</span> <span class="o">(</span><span class="n">out3</span><span class="o">,</span> <span class="n">tick3</span><span class="o">))</span> <span class="k">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">st2</span><span class="o">,</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">e3</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span><span class="o">))</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">count3</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">tick3</span><span class="o">,</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">out3</span><span class="o">,</span> <span class="n">res3</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">gems</span><span class="o">(</span><span class="n">res3</span><span class="o">),</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">level</span><span class="o">(</span><span class="n">res3</span><span class="o">),</span> <span class="n">e3</span><span class="o">.</span><span class="n">newLevel</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">points</span><span class="o">(</span><span class="n">res3</span><span class="o">),</span> <span class="mi">160</span><span class="o">)</span>

    <span class="c1">// at the end of the stream, both the counter and the tick timer are reseted</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">st4</span> <span class="k">@</span> <span class="o">(</span><span class="n">res4</span><span class="o">,</span> <span class="n">count4</span><span class="o">),</span> <span class="o">(</span><span class="n">out4</span><span class="o">,</span> <span class="n">tick4</span><span class="o">))</span> <span class="k">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">st3</span><span class="o">,</span> <span class="o">(</span><span class="nc">None</span> <span class="o">-&gt;</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span><span class="o">))</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">count4</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">tick4</span><span class="o">,</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">On</span><span class="o">)</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">res4</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">gems</span><span class="o">(</span><span class="n">out4</span><span class="o">),</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">level</span><span class="o">(</span><span class="n">res4</span><span class="o">),</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">points</span><span class="o">(</span><span class="n">out4</span><span class="o">),</span> <span class="mi">160</span><span class="o">)</span>

    <span class="k">val</span> <span class="o">((</span><span class="n">res5</span><span class="o">,</span> <span class="n">count5</span><span class="o">),</span> <span class="o">(</span><span class="n">out5</span><span class="o">,</span> <span class="n">tick5</span><span class="o">))</span> <span class="k">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">st4</span><span class="o">,</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span><span class="o">))</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">count5</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">tick5</span><span class="o">,</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">out5</span><span class="o">,</span> <span class="n">res5</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">gems</span><span class="o">(</span><span class="n">res5</span><span class="o">),</span> <span class="mi">1</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">level</span><span class="o">(</span><span class="n">res5</span><span class="o">),</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">points</span><span class="o">(</span><span class="n">res5</span><span class="o">),</span> <span class="mi">10</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></div> <p>Let’s break it apart.</p> <ol> <li>We run our FSM with an initial empty state and our first event: <code>GemCollected</code>. Once we get the result, we run a few assertions on it. The two most important ones are that the total number of gems equals one and the total amount of points equals ten.</li> <li>We run our FSM with the previous state, namely <code>st1</code>, and a second event: <code>PuzzleSolved</code>. The procedure is mostly the same. The most important assertions are that we still keep the previous gem and that our points have been increased to sixty.</li> <li>We run our FSM with the previous state, namely <code>st2</code>, and a third event: <code>LevelUp</code>. In addition to the previous assertions, we also verify that a new level has been set.</li> <li>We run our FSM with the previous state, namely <code>st3</code>, and no event (<code>None</code>). In addition to the previous assertions, we also verify that counter has been reseted and the tick is now on.</li> <li>Lastly, we run our FSM with the previous state, namely <code>st4</code>, and the first event once again: <code>GemCollected</code>. The assertion is now identical to our first case.</li> </ol> <p>You can find more unit tests for our FSM in the <a href="https://github.com/gvolpe/fsm-streams">repository</a>.</p> <h4 id="streaming">Streaming</h4> <p>If we give it a closer look, we will recognize the type signature of <a href="https://github.com/typelevel/fs2/blob/v2.4.5/core/shared/src/main/scala/fs2/Stream.scala#L1705">mapAccumulate</a> as a finite-state machine lifted into a streaming context.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">mapAccumulate</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">O2</span><span class="o">](</span><span class="n">init</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">S</span><span class="o">,</span> <span class="kt">O</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">S</span><span class="o">,</span> <span class="n">O2</span><span class="o">))</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">F</span>, <span class="o">(</span><span class="kt">S</span>, <span class="kt">O2</span><span class="o">)]</span></code></pre></div> <p>There’s also <code>evalMapAccumulate</code> for dealing with effectful state transitions, which is the one we will be using in our solution. Let’s bring it up again and describe each step in detail.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">Engine</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Concurrent:</span> <span class="kt">Parallel:</span> <span class="kt">Time:</span> <span class="kt">Timer</span><span class="o">](</span>
    <span class="n">publish</span><span class="k">:</span> <span class="kt">Summary</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">],</span>
    <span class="n">ticker</span><span class="k">:</span> <span class="kt">Ticker</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">)</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">fsm</span> <span class="k">=</span> <span class="nc">Engine</span><span class="o">.</span><span class="n">fsm</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="n">ticker</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">run</span><span class="k">:</span> <span class="kt">Pipe</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Event</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">_</span><span class="o">.</span><span class="n">noneTerminate</span>
      <span class="o">.</span><span class="n">zip</span><span class="o">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">ticks</span><span class="o">)</span>
      <span class="o">.</span><span class="n">evalMapAccumulate</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">PlayerId</span>, <span class="kt">Agg</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">)(</span><span class="n">fsm</span><span class="o">.</span><span class="n">run</span><span class="o">)</span>
      <span class="o">.</span><span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">On</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">out</span> <span class="o">}</span>
      <span class="o">.</span><span class="n">evalMap</span> <span class="o">{</span> <span class="n">m</span> <span class="k">=&gt;</span>
        <span class="n">F</span><span class="o">.</span><span class="n">timestamp</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">ts</span> <span class="k">=&gt;</span>
          <span class="n">m</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">parTraverse_</span> <span class="o">{</span>
            <span class="k">case</span> <span class="o">(</span><span class="n">pid</span><span class="o">,</span> <span class="n">agg</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">publish</span><span class="o">(</span><span class="n">agg</span><span class="o">.</span><span class="n">summary</span><span class="o">(</span><span class="n">pid</span><span class="o">,</span> <span class="n">ts</span><span class="o">))</span>
          <span class="o">}</span>
        <span class="o">}</span>
      <span class="o">}</span>
<span class="o">}</span></code></pre></div> <p>To begin with, we have a <code>Pipe[F, Event, Unit]</code>, which is merely an alias for a function <code>Stream[F, Event] =&gt; Stream[F, Unit]</code>. Firstly, we call <code>noneTerminate</code>, which will lift our <code>Event</code> into an <code>Option[Event]</code>, giving us a <code>Stream[F, Option[Event]]</code>. The reason for doing so, is that we want to accumulate and aggregate events in memory before emitting a summary but, in case the stream terminates, that last aggregation won’t be emitted. So we handle this case with the <code>None</code> case in our state machine.</p> <p>Next, we <code>zip</code> our input with the output of a <code>Stream[F, Tick]</code>, yielding a <code>Stream[F, (Option[Event], Tick)]</code>. This is effectively the input type of our state machine. A tick will be produced either when the given time window has passed or when the number of processed events has been reached, whichever happens first. We will later dive into the <code>Ticker</code> implementation.</p> <p>Continuing, we <code>evalMapAccumulate</code> with an initial state: an empty map and counter set to zero. As mentioned before, both <code>mapAccumulate</code> and <code>evalMapAccumulate</code> fit the type signature of a finite-state machine, so here we call <code>fsm.run</code>. These events will be aggregated in memory until our tick becomes <code>Tick.On</code>.</p> <p>Which takes us to <code>collect { case (_, (out, Tick.On)) =&gt; out }</code>. The current aggregation will be only emitted when we get a tick.</p> <p>Finally, we create a timestamp - which comes from a custom <code>Time</code> interface - and proceed to publish a <code>Summary</code> for every player, by using the given <code>publish</code> function.</p> <h4 id="boolean-blindness">Boolean blindness</h4> <p><code>Tick</code> is a simple datatype used to avoid <a href="https://runtimeverification.com/blog/code-smell-boolean-blindness/">boolean blindness</a>. However, it also forms a <code>Semigroup</code>. In the next section, you will understand how this is useful.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">cats.</span><span class="o">{</span><span class="nc">Eq</span><span class="o">,</span> <span class="nc">Semigroup</span><span class="o">}</span>

<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Tick</span>
<span class="k">object</span> <span class="nc">Tick</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">On</span>  <span class="k">extends</span> <span class="nc">Tick</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Off</span> <span class="k">extends</span> <span class="nc">Tick</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">eq</span><span class="k">:</span> <span class="kt">Eq</span><span class="o">[</span><span class="kt">Tick</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Eq</span><span class="o">.</span><span class="n">fromUniversalEquals</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">semigroup</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">Tick</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">Tick</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">combine</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Tick</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Tick</span><span class="o">)</span><span class="k">:</span> <span class="kt">Tick</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="o">(</span><span class="nc">On</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span>    <span class="k">=&gt;</span> <span class="nc">On</span>
        <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">On</span><span class="o">)</span>    <span class="k">=&gt;</span> <span class="nc">On</span>
        <span class="k">case</span> <span class="o">(</span><span class="nc">Off</span><span class="o">,</span> <span class="nc">Off</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Off</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div> <h4 id="ticker">Ticker</h4> <p>Fs2 provides a function named <a href="https://github.com/typelevel/fs2/blob/v2.5.0/core/shared/src/main/scala/fs2/Stream.scala#L3187">every</a>, which constantly emits a tick expressed as a <code>boolean</code>. Whenever the specified duration is reached, it evaluates to <code>true</code>. Otherwise, it evaluates to <code>false</code>. However, we can’t make use of it because we also need to consider the number of events that have been processed so far. Whatever happens first, both the tick’s timer and the events counter need to be reseted. Here’s where our custom <code>Ticker</code> comes into play.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">Ticker</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Tick</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">timerTick</span><span class="k">:</span> <span class="kt">Tick</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Count</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">Tick</span>, <span class="kt">Count</span><span class="o">)]</span>
  <span class="k">def</span> <span class="n">ticks</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Tick</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Ticker</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Count</span> <span class="o">=</span> <span class="nc">Int</span>

  <span class="k">def</span> <span class="n">create</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Concurrent:</span> <span class="kt">Timer</span><span class="o">](</span>
      <span class="n">maxNrOfEvents</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
      <span class="n">timeWindow</span><span class="k">:</span> <span class="kt">FiniteDuration</span>
  <span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Ticker</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">Ref</span><span class="o">.</span><span class="n">of</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Tick</span><span class="o">](</span><span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="n">ref</span> <span class="k">=&gt;</span>
      <span class="k">new</span> <span class="nc">Ticker</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">get</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Tick</span><span class="o">]</span> <span class="k">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">get</span>

        <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">timerTick</span><span class="k">:</span> <span class="kt">Tick</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Count</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">Tick</span>, <span class="kt">Count</span><span class="o">)]</span> <span class="k">=</span>
          <span class="n">ref</span>
            <span class="o">.</span><span class="n">modify</span> <span class="o">{</span>
              <span class="k">case</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span> <span class="k">if</span> <span class="n">count</span> <span class="o">===</span> <span class="n">maxNrOfEvents</span> <span class="k">=&gt;</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">On</span>  <span class="o">-&gt;</span> <span class="mi">0</span>
              <span class="k">case</span> <span class="k">_</span> <span class="k">if</span> <span class="n">timerTick</span> <span class="o">===</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">On</span>          <span class="k">=&gt;</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span> <span class="o">-&gt;</span> <span class="mi">0</span>
              <span class="k">case</span> <span class="k">_</span>                                   <span class="k">=&gt;</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
            <span class="o">}</span>
            <span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">newCount</span> <span class="k">=&gt;</span>
              <span class="n">get</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">counterTick</span> <span class="k">=&gt;</span>
                <span class="k">val</span> <span class="n">newTick</span> <span class="k">=</span> <span class="n">counterTick</span> <span class="o">|+|</span> <span class="n">timerTick</span>
                <span class="n">newTick</span> <span class="o">-&gt;</span> <span class="n">newCount</span>
              <span class="o">}</span>
            <span class="o">}</span>

        <span class="k">def</span> <span class="n">ticks</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Tick</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
          <span class="k">val</span> <span class="n">duration</span> <span class="k">=</span> <span class="n">timeWindow</span><span class="o">.</span><span class="n">toNanos</span>
          <span class="k">val</span> <span class="n">interval</span> <span class="k">=</span> <span class="nc">FiniteDuration</span><span class="o">((</span><span class="n">timeWindow</span><span class="o">.</span><span class="n">toSeconds</span> <span class="o">*</span> <span class="mf">0.05</span><span class="o">).</span><span class="n">toLong</span><span class="o">,</span> <span class="nc">SECONDS</span><span class="o">).</span><span class="n">toNanos</span>

          <span class="k">def</span> <span class="n">go</span><span class="o">(</span><span class="n">lastSpikeNanos</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Tick</span><span class="o">]</span> <span class="k">=</span>
            <span class="nc">Stream</span><span class="o">.</span><span class="n">eval</span><span class="o">((</span><span class="n">F</span><span class="o">.</span><span class="n">monotonic</span><span class="o">(</span><span class="nc">NANOSECONDS</span><span class="o">),</span> <span class="n">get</span><span class="o">).</span><span class="n">tupled</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
              <span class="k">case</span> <span class="o">(</span><span class="n">now</span><span class="o">,</span> <span class="n">tick</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">now</span> <span class="o">-</span> <span class="n">lastSpikeNanos</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">duration</span> <span class="o">||</span> <span class="o">(</span><span class="n">tick</span> <span class="o">===</span> <span class="nc">Tick</span><span class="o">.</span><span class="nc">On</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">lastSpikeNanos</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">interval</span><span class="o">))</span>
                  <span class="nc">Stream</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="nc">Tick</span><span class="o">.</span><span class="nc">On</span><span class="o">)</span> <span class="o">++</span> <span class="n">go</span><span class="o">(</span><span class="n">now</span><span class="o">)</span>
                <span class="k">else</span> <span class="nc">Stream</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="nc">Tick</span><span class="o">.</span><span class="nc">Off</span><span class="o">)</span> <span class="o">++</span> <span class="n">go</span><span class="o">(</span><span class="n">lastSpikeNanos</span><span class="o">)</span>
            <span class="o">}</span>

          <span class="n">go</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">tail</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div> <p>In the <a href="https://github.com/gvolpe/fsm-streams">Github repository</a>, you will also find scaladocs on each method and unit tests for this implementation. Though, in the meantime, let’s analyze each function.</p> <p>Our first function, <code>get</code>, is the simplest one. It retrieves the current state of the counter tick.</p> <p>Next, we have <code>merge</code>, which takes a timer tick and a count and returns a tuple <code>(Tick, Count)</code>, possibly running some effects. In a nutshell, this function is the responsible for resetting both the counter and time ticks, as well as keeping track of the count. Ultimately, the tick response we get is the result of the combination of the counter tick and the timer tick by relying on the <code>Semigroup[Tick]</code> instance we’ve seen before.</p> <p>Finally, our <code>ticks</code> function is the analog to the <code>Stream.every</code> function that also considers the current state of the counter ticks. It also emits a <code>Tick</code> instead of a <code>boolean</code>.</p> <h3 id="credits">Credits</h3> <p>Initially, my first solution was based on <code>evalMapAccumulate</code> + <code>debounce</code> + <code>Ref</code> but after asking for feedback, <a href="https://github.com/wemrysi">Emrys Ingersoll</a> came up with a solution based on <code>noneTerminate</code> + <code>mapAccumulate</code> + <code>collect</code>, which is the one I used for the final solution so credits where due, thanks again Emrys!</p> <h3 id="summary">Summary</h3> <p>This was a really fun problem to solve! I hope you have enjoyed reading about it. As a bonus track, here are some graphics showing how this performs under heavy load of events coming in from an Apache Pulsar topic.</p> <p><img src="../images/metrics1.png" alt="m1" /></p> <p><img src="../images/metrics2.png" alt="m1" /></p> <p>I can’t disclose more information than you can see in these JVM metrics but the GC pauses are interesting to observe, which makes sense given that we allocate quite a lot of objects in memory during the aggregation time window.</p> <p>Cheers, Gabriel.</p> <aside class="share"> <span>Share this: </span> <a href="http://twitter.com/share?text=Finite-State Machines + FS2 streams: A match made in heaven&amp;url=https://gvolpe.github.io/fsm-fs2-a-match-made-in-heaven/&amp;hashtags=scala,haskell,fp&amp;via=volpegabriel87" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;"> <i class="fa fa-twitter-square"></i> </a> </aside> <div id="gh-comments"> <br/><br/> <h6>COMMENTS</h6> <div id="gh-comments-list"></div> </div> <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script> <script src="/blog/js/github-comments.js"> </script> <script type="text/javascript"> DoGithubComments ( "gvolpe/blog" , "11" ); </script> <noscript>Please enable JavaScript to view comments.</noscript> </div> </article> <footer class="footer t-center"> <div class="container"> <div class="social-icons"> <ul class="text-left"> <li><a href="https://twitter.com/volpegabriel87" target="_blank"><i class="fa fa-twitter"></i></a></li> </ul> </div> <small>&copy; 2024 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small> <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small> </div> </footer> </main> </body> </html></body></html>
<!--
// # Zetsu Jekyll theme - https://github.com/nandomoreriame/zetsu/
// by nandomoreira.me
-->
