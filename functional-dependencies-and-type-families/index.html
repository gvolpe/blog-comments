<!DOCTYPE html> <html lang="en-uk"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> Functional Dependencies & Type Families &bull; gvolpe's blog </title> <meta name="description" content="In the past few months I have learnt a lot! Probably the coolest stuff has been about Functional Dependencies and Type Families, so this is my attempt to exp..."> <link rel="stylesheet" href="/blog/css/main.css"> <link rel="canonical" href="https://gvolpe.github.io/blog/functional-dependencies-and-type-families/"> <link rel="alternate" type="application/rss+xml" title="gvolpe's blog" href="https://gvolpe.github.io/blog/feed.xml" /> <script defer type="text/javascript" src="https://api.pirsch.io/pirsch.js" id="pirschjs" data-code="db2twsz97grcqToSsEMhvcQXm8rLaFmQ"> </script> </head> <body class="single"> <main class="main"> <header class="header"> <div class="overlay"> <div class="container"> <h1 class="title"> <a href="/blog/">gvolpe's blog</a> </h1> <nav class="navbar"> <a href="#" class="menu-icon"> <span></span> <span></span> <span></span> </a> <ul class="nav"> <li><a href="https://gvolpe.com" target="_blank">Website</a></li> </ul> </nav> </div> </div> </header> <article class="post container card"> <header class="post-header"> <h1 class="post-title">Functional Dependencies & Type Families</h1> <span class="post-meta"> <time class="post-date" datetime="2019-08-27">Aug 27, 2019</time> <span class="post-author">by Gabriel Volpe</span> </span> </header> <div class="post-content"> <p>In the past few months I have learnt a lot! Probably the coolest stuff has been about <a href="https://wiki.haskell.org/Functional_dependencies">Functional Dependencies</a> and <a href="https://wiki.haskell.org/GHC/Type_families">Type Families</a>, so this is my attempt to explain it in order to gain a better understanding and hopefully help someone else out there as well.</p> <p>So please be kind if you see any mistake, let me know and I’ll try to fix it :)</p> <h3 id="a-motivating-example">A motivating example</h3> <p>One of the fun applications I’ve worked on is <a href="https://github.com/gvolpe/exchange-rates">exchange-rates</a>, which uses the <a href="https://www.fpcomplete.com/blog/2017/07/the-rio-monad">RIO Monad</a> (basically <code>ReaderT</code> + <code>IO</code>).</p> <p>When defining dependencies using such effect is very common to do it using the <a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern">Has typeclass approach</a> (or how I prefer to call it, the <em>classy lenses Has pattern</em>) instead of passing the whole context / environment.</p> <p>Following this approach, I have defined a polymorphic <code>Ctx</code> record that represents the application context (or dependencies). It looks as follows:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Ctx</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">Ctx</span>
  <span class="p">{</span> <span class="n">ctxLogger</span> <span class="ow">::</span> <span class="kt">Logger</span> <span class="n">m</span>
  <span class="p">,</span> <span class="n">ctxCache</span> <span class="ow">::</span> <span class="kt">Cache</span> <span class="n">m</span>
  <span class="p">,</span> <span class="n">ctxForexClient</span> <span class="ow">::</span> <span class="kt">ForexClient</span> <span class="n">m</span>
  <span class="p">}</span></code></pre></div> <p>If we continue with the <code>Has</code> approach we would get something like this for our <code>Logger m</code>:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">HasLogger</span> <span class="n">ctx</span> <span class="kr">where</span>
  <span class="n">loggerL</span> <span class="ow">::</span> <span class="kt">Lens&#39;</span> <span class="n">ctx</span> <span class="p">(</span><span class="kt">Logger</span> <span class="n">m</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">HasLogger</span> <span class="p">(</span><span class="kt">Ctx</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">loggerL</span> <span class="ow">=</span> <span class="n">lens</span> <span class="n">ctxLogger</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="p">{</span> <span class="n">ctxLogger</span> <span class="ow">=</span> <span class="n">y</span> <span class="p">})</span></code></pre></div> <p>But… Oops, it doesn’t compile!</p> <div class="highlight"><pre><code class="language-bash" data-lang="bash">Couldn<span class="s1">&#39;t match type ‘m1’ with ‘m’</span>
<span class="s1">      ‘m1’ is a rigid type variable bound by</span>
<span class="s1">        the type signature for:</span>
<span class="s1">          loggerL :: forall (m1 :: * -&gt; *). Lens&#39;</span> <span class="o">(</span>Ctx m<span class="o">)</span> <span class="o">(</span>Logger m1<span class="o">)</span>
        at src/Context.hs:27:3-9
      ‘m’ is a rigid <span class="nb">type </span>variable bound by
        the instance declaration
        at src/Context.hs:26:10-47</code></pre></div> <p>The reason is that the compiler has no way to know that the <code>m</code> in <code>Logger m</code> (declared in the type class) is the same as the <code>m</code> in <code>Ctx m</code> (declared in the instance), therefore the inferred type ends up being <code>Lens' (Ctx m) (Logger m1)</code>.</p> <h3 id="functional-dependencies-to-the-rescue">Functional Dependencies to the rescue</h3> <p>We can fix it by introducing a language extension named <a href="https://wiki.haskell.org/Functional_dependencies">FunctionalDependencies</a>, introduced in the paper <a href="https://web.cecs.pdx.edu/~mpj/pubs/fundeps-esop2000.pdf">Type Classes with Functional Dependencies</a> by Mark P. Jones in March 2000.</p> <p>We need to change our type class definition as below:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="cm">{-# LANGUAGE FlexibleInstances      #-}</span>
<span class="cm">{-# LANGUAGE FunctionalDependencies #-}</span>
<span class="cm">{-# LANGUAGE MultiParamTypeClasses  #-}</span>

<span class="kr">class</span> <span class="kt">HasLogger</span> <span class="n">ctx</span> <span class="n">m</span> <span class="o">|</span> <span class="n">ctx</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">loggerL</span> <span class="ow">::</span> <span class="kt">Lens&#39;</span> <span class="n">ctx</span> <span class="p">(</span><span class="kt">Logger</span> <span class="n">m</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">HasLogger</span> <span class="p">(</span><span class="kt">Ctx</span> <span class="n">m</span><span class="p">)</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">loggerL</span> <span class="ow">=</span> <span class="n">lens</span> <span class="n">ctxLogger</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="p">{</span> <span class="n">ctxLogger</span> <span class="ow">=</span> <span class="n">y</span> <span class="p">})</span></code></pre></div> <p>Our type class has now two parameters, <code>ctx</code> and <code>m</code>, and in addition we define a <em>functional dependency</em> <code>ctx -&gt; m</code>. This means that <code>ctx</code> uniquely determines the type of <code>m</code>, which constraints the possible instances and helps with type inference.</p> <blockquote> <p>Notice the extensions we had to enable to make this compile.</p> </blockquote> <h5 id="arithmetic-example">Arithmetic example</h5> <p>Here’s another example taken from the <a href="http://www.cse.chalmers.se/~hallgren/Papers/hallgren.pdf">Fun with Functional Dependencies</a> paper by Thomas Hallgren. What’s simpler that adding two values together?</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Add</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">|</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="kr">where</span>
  <span class="n">add</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span>

<span class="kr">instance</span> <span class="kt">Add</span> <span class="kt">Zero</span> <span class="n">b</span> <span class="n">b</span>
<span class="kr">instance</span> <span class="kt">Add</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=&gt;</span> <span class="kt">Add</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">a</span><span class="p">)</span> <span class="n">b</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">c</span><span class="p">)</span></code></pre></div> <p>The functional dependency is pretty clear: given <code>a</code> and <code>b</code> we can add them together and produce <code>c</code>. So <code>a</code> and <code>b</code> uniquely determine <code>c</code>.</p> <p>Notice how we don’t even need to define <code>add</code>, specifying the types is enough! If it’s still not clear, bear with me and let’s perform type substitution step by step (feel free to skip this part):</p> <p>Given this instance, all we are saying is that:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Add</span> <span class="kt">Zero</span> <span class="n">b</span> <span class="n">b</span> <span class="kr">where</span></code></pre></div> <ul> <li><code>a</code> is defined as <code>Zero</code>.</li> <li><code>b</code> is defined as <code>b</code>.</li> <li><code>c</code> is defined as <code>b</code>.</li> </ul> <p>Since we now know the types of <code>a</code>, <code>b</code> and <code>c</code>, defining the <code>add</code> function becomes redundant:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Add</span> <span class="kt">Zero</span> <span class="n">b</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="n">add</span> <span class="kt">Zero</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">b</span></code></pre></div> <p>Clear now? Awesome! Let’s try this out in the REPL:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">λ</span> <span class="kt">:</span><span class="n">t</span> <span class="n">add</span> <span class="p">(</span><span class="n">u</span><span class="ow">::</span><span class="kt">Three</span><span class="p">)</span> <span class="p">(</span><span class="n">u</span><span class="ow">::</span><span class="kt">Zero</span><span class="p">)</span>
<span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="kt">Zero</span><span class="p">))</span></code></pre></div> <blockquote> <p>Where <code>u = undefined</code>, just a convenient type alias.</p> </blockquote> <p>Functional Dependencies have proven to be very useful since it solves a real problem. But software evolves and so Type Families were created, the topic of the next section.</p> <h3 id="type-families">Type Families</h3> <p>Type Families were introduced in the paper <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/typefun.pdf?from=http%3A%2F%2Fresearch.microsoft.com%2F~simonpj%2Fpapers%2Fassoc-types%2Ffun-with-type-funs%2Ftypefun.pdf">Fun with type functions</a> by Oleg Kiselyov, Simon Peyton Jones and Chung-chieh Shan in May 2010.</p> <p>This GHC extension allows functions on types to be expressed as straightforwardly as functions on values. This means that our functions are executed at compile time, during type checking.</p> <p>So here’s how we can define our <code>HasLogger</code> class using Type Families instead:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="cm">{-# LANGUAGE TypeFamilies #-}</span>

<span class="kr">import</span> <span class="nn">Data.Kind</span> <span class="p">(</span><span class="kt">Type</span><span class="p">)</span>

<span class="kr">class</span> <span class="kt">HasLogger</span> <span class="n">ctx</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">LoggerF</span> <span class="n">ctx</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span>
  <span class="n">loggerL</span> <span class="ow">::</span> <span class="kt">Lens&#39;</span> <span class="n">ctx</span> <span class="p">(</span><span class="kt">Logger</span> <span class="p">(</span><span class="kt">LoggerF</span> <span class="n">ctx</span><span class="p">))</span>

<span class="kr">instance</span> <span class="kt">HasLogger</span> <span class="p">(</span><span class="kt">Ctx</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">LoggerF</span> <span class="p">(</span><span class="kt">Ctx</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=</span> <span class="n">m</span>
  <span class="n">loggerL</span> <span class="ow">=</span> <span class="n">lens</span> <span class="n">ctxLogger</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="p">{</span> <span class="n">ctxLogger</span> <span class="ow">=</span> <span class="n">y</span> <span class="p">})</span></code></pre></div> <p>Our class has once again a single parameter <code>ctx</code> and our functional dependency is now expressed as an <em>associated type</em> of the class (type family). It behaves like a function at the type level, so we can call <code>LoggerF</code> a type function.</p> <p>Notice how we explicitly define the kind of our type function to be <code>Type -&gt; Type</code> (formerly <code>* -&gt; *</code>). If we don’t do it the default inferred kind will just be <code>Type</code> (formerly <code>*</code>).</p> <h5 id="arithmetic-example-1">Arithmetic example</h5> <p>In a similar way, we can define the <code>Add</code> class using Type Families:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Add</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">AddF</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">::</span> <span class="kt">Type</span>
  <span class="n">add</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">AddF</span> <span class="n">a</span> <span class="n">b</span>

<span class="kr">instance</span> <span class="kt">Add</span> <span class="kt">Zero</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">AddF</span> <span class="kt">Zero</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">b</span>

<span class="kr">instance</span> <span class="kt">Add</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="kt">Add</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">a</span><span class="p">)</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">AddF</span> <span class="p">(</span><span class="kt">Succ</span> <span class="n">a</span><span class="p">)</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Succ</span> <span class="p">(</span><span class="kt">AddF</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span></code></pre></div> <p>The <code>c</code> parameter defined before is now replaced by the <code>AddF a b</code> type function. Here we define the kind of the type function as a good practice but it’s not necessary.</p> <p>And again, we can try this out in the REPL:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">λ</span> <span class="kt">:</span><span class="n">t</span> <span class="n">add</span> <span class="p">(</span><span class="n">u</span><span class="ow">::</span><span class="kt">Three</span><span class="p">)</span> <span class="p">(</span><span class="n">u</span><span class="ow">::</span><span class="kt">Succ</span> <span class="kt">Zero</span><span class="p">)</span>
<span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="p">(</span><span class="kt">Succ</span> <span class="kt">Zero</span><span class="p">)))</span></code></pre></div> <h5 id="polymorphic-mutable-ref">Polymorphic Mutable Ref</h5> <p>Furthermore, with Type Families we could define a polymorphic mutable ref class where <code>m</code> defines <code>Ref</code> (example taken from the paper <em>Fun with type functions</em> linked above).</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Mutation</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Ref</span> <span class="n">m</span> <span class="ow">::</span> <span class="kt">Type</span> <span class="ow">-&gt;</span> <span class="kt">Type</span>
  <span class="n">newRef</span>   <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Ref</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">readRef</span>  <span class="ow">::</span> <span class="kt">Ref</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
  <span class="n">writeRef</span> <span class="ow">::</span> <span class="kt">Ref</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>

<span class="kr">instance</span> <span class="kt">Mutation</span> <span class="kt">IO</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Ref</span> <span class="kt">IO</span> <span class="ow">=</span> <span class="kt">IORef</span>
  <span class="n">newRef</span>   <span class="ow">=</span> <span class="n">newIORef</span>
  <span class="n">readRef</span>  <span class="ow">=</span> <span class="n">readIORef</span>
  <span class="n">writeRef</span> <span class="ow">=</span> <span class="n">writeIORef</span>

<span class="kr">instance</span> <span class="kt">Mutation</span> <span class="p">(</span><span class="kt">ST</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Ref</span> <span class="p">(</span><span class="kt">ST</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">STRef</span> <span class="n">s</span>
  <span class="n">newRef</span>   <span class="ow">=</span> <span class="n">newSTRef</span>
  <span class="n">readRef</span>  <span class="ow">=</span> <span class="n">readSTRef</span>
  <span class="n">writeRef</span> <span class="ow">=</span> <span class="n">writeSTRef</span></code></pre></div> <p>Once the compiler knows what <code>m</code> is it’s over. It’ll know what the type of the mutable ref is as well. And as a bonus, type inference will work flawlessly.</p> <h3 id="final-thoughts">Final Thoughts</h3> <p>Most use cases of <code>FunctionalDependencies</code> can be expressed using <code>TypeFamilies</code>, however there are some subtle differences that come to light only in complex scenarios.</p> <p>Most library authors and developers prefer to use <code>TypeFamilies</code> nowadays. Its main advantage over <code>FunctionalDependencies</code> is speed but it’s also possible to express many cases that require the extensions <code>TypeSynonymInstances</code>, <code>FlexibleInstances</code>, <code>MultiParamTypeClasses</code> and <code>UndecidableInstances</code> without them.</p> <p>So when is it more convenient to use the former? You can find a more detailed comparison in the following articles:</p> <ul> <li>https://wiki.haskell.org/Functional_dependencies_vs._type_families</li> <li>https://gitlab.haskell.org/ghc/ghc/wikis/tf-vs-fd</li> </ul> <p>Special thanks to <a href="https://twitter.com/ChShersh">Dmitrii Kovanikov</a> for reviewing the first draft!</p> <aside class="share"> <span>Share this: </span> <a href="http://twitter.com/share?text=Functional Dependencies & Type Families&amp;url=https://gvolpe.github.io/functional-dependencies-and-type-families/&amp;hashtags=scala,haskell,fp&amp;via=volpegabriel87" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;"> <i class="fa fa-twitter-square"></i> </a> </aside> </div> </article> <footer class="footer t-center"> <div class="container"> <div class="social-icons"> <ul class="text-left"> <li><a href="https://twitter.com/volpegabriel87" target="_blank"><i class="fa fa-twitter"></i></a></li> </ul> </div> <small>&copy; 2022 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small> <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small> </div> </footer> </main> </body> </html></body></html>
<!--
// # Zetsu Jekyll theme - https://github.com/nandomoreriame/zetsu/
// by nandomoreira.me
-->
