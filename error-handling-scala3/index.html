<!DOCTYPE html> <html lang="en-uk"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> Scala 3: Error handling in FP land &bull; gvolpe's blog </title> <meta name="description" content="Table of contents"> <link rel="stylesheet" href="/blog/css/main.css"> <link rel="canonical" href="https://gvolpe.github.io/blog/error-handling-scala3/"> <link rel="alternate" type="application/rss+xml" title="gvolpe's blog" href="https://gvolpe.github.io/blog/feed.xml" /> <script defer type="text/javascript" src="https://api.pirsch.io/pirsch.js" id="pirschjs" data-code="db2twsz97grcqToSsEMhvcQXm8rLaFmQ"> </script> </head> <body class="single"> <main class="main"> <header class="header"> <div class="overlay"> <div class="container"> <h1 class="title"> <a href="/blog/">gvolpe's blog</a> </h1> <nav class="navbar"> <a href="#" class="menu-icon"> <span></span> <span></span> <span></span> </a> <ul class="nav"> <li><a href="https://gvolpe.com" target="_blank">Website</a></li> </ul> </nav> </div> </div> </header> <article class="post container card"> <header class="post-header"> <h1 class="post-title">Scala 3: Error handling in FP land</h1> <span class="post-meta"> <time class="post-date" datetime="2022-02-08">Feb 8, 2022</time> <span class="post-author">by Gabriel Volpe</span> </span> </header> <div class="post-content"> <h3 id="table-of-contents">Table of contents</h3> <ul> <li><a href="#introduction">Introduction</a></li> <li><a href="#error-types">Error types</a> <ul> <li><a href="#union-types-to-the-rescue">Union types to the rescue!</a></li> </ul> </li> <li><a href="#error-handling">Error handling</a> <ul> <li><a href="#bottom-layer">Bottom layer</a></li> <li><a href="#middle-layer">Middle layer</a></li> <li><a href="#top-layer">Top layer</a></li> </ul> </li> <li><a href="#furthermore">Furthermore</a></li> <li><a href="#conclusion">Conclusion</a></li> </ul> <h3 id="introduction">Introduction</h3> <p>Scala 3 introduces <a href="https://docs.scala-lang.org/scala3/reference/new-types/union-types.html">union types</a>. Straight from the official documentation, a union type <code>A | B</code> has as values all values of type <code>A</code> and also all values of type <code>B</code>.</p> <p>So the following code snippet compiles performing an exhaustive pattern-matching.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">foo</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">|</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="n">x</span> <span class="k">match</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">Int</span>  <span class="o">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;Int!!!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_:</span> <span class="kt">Long</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;Long!!!&quot;</span><span class="o">)</span></code></pre></div> <p>However, you are not here for boring examples, are you? :)</p> <h3 id="error-types">Error types</h3> <p>Union types are the perfect feature to model error types. In Scala 2, we could represent the presence of errors via the <code>Either</code> monad. E.g.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">Err</span> <span class="o">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">UserNotFound</span>, <span class="kt">Unit</span><span class="o">]</span></code></pre></div> <p>However, if we want to model other errors, we can either get into <a href="https://github.com/milessabin/shapeless/blob/70076c2/core/src/main/scala/shapeless/coproduct.scala">Shapeless’ Coproducts</a> (fairly common during the Free Monad hype-era!) or into nested <code>Either</code>s (arghhh). E.g.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">Err</span> <span class="o">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">DuplicateStory</span>, <span class="kt">UserNotFound</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span></code></pre></div> <p>Though, as we usually work in some <code>F[_]</code> context, you can imagine things get only much more complicated and less ergonomic from here.</p> <h4 id="union-types-to-the-rescue">Union types to the rescue!</h4> <p>With union types, we can keep a single <code>Either</code> instead.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">Err</span> <span class="o">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">DuplicateStory</span> <span class="kt">|</span> <span class="kt">UserNotFound</span>, <span class="kt">Unit</span><span class="o">]</span></code></pre></div> <p>Or we could eliminate the <code>Either</code> type altogether!</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">Err</span> <span class="o">=</span> <span class="nc">DuplicateStory</span> <span class="o">|</span> <span class="nc">UserNotFound</span> <span class="o">|</span> <span class="nc">Unit</span></code></pre></div> <p>Much nicer! Now, how do we get this to play nicely in the <code>F</code> context? Bear with me a little longer.</p> <h3 id="error-handling">Error handling</h3> <p>In my experience, error types are only desirable at the bottom layers. Most of the error handling should occur at the mid layers (business logic) where the errors are eliminated, or perhaps a few errors should be left for the top layers to handle.</p> <p>To put these words into an example, let’s say we work with a three-layer application.</p> <h4 id="bottom-layer">Bottom layer</h4> <p>At the bottom level, we have an <code>UserStore</code> that interacts with a database.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">UserStore</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="nc">:</span>
  <span class="k">def</span> <span class="n">fetch</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">DuplicateEmail</span> <span class="kt">|</span> <span class="kt">DuplicateUsername</span>, <span class="kt">Unit</span><span class="o">]]</span></code></pre></div> <p>Where the error types are subtypes of <code>Throwable</code> (this will make our lives easier).</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">scala.util.control.NoStackTrace</span>

<span class="k">case</span> <span class="k">object</span> <span class="nc">DuplicateEmail</span> <span class="k">extends</span> <span class="nc">NoStackTrace</span>
<span class="k">type</span> <span class="kt">DuplicateEmail</span> <span class="o">=</span> <span class="nc">DuplicateEmail</span><span class="o">.</span><span class="k">type</span>

<span class="kt">case</span> <span class="kt">object</span> <span class="kt">DuplicateUsername</span> <span class="kt">extends</span> <span class="kt">NoStackTrace</span>
<span class="k">type</span> <span class="kt">DuplicateUsername</span> <span class="o">=</span> <span class="nc">DuplicateUsername</span><span class="o">.</span><span class="k">type</span></code></pre></div> <p>If you have read my book <a href="https://leanpub.com/pfp-scala">Practical FP in Scala</a>, you know I am not a big fan of stack traces :)</p> <h4 id="middle-layer">Middle layer</h4> <p>Now at the middle layer, we might have our business logic, making calls to the <code>UserStore</code>, and perhaps to other components that interact with the outside world.</p> <p>In the following mid layer, our aim is to handle all declared errors, so we pattern match on all cases.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">mid1</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Logger:</span> <span class="kt">MonadThrow</span><span class="o">](</span>
    <span class="n">producer</span><span class="k">:</span> <span class="kt">Producer</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">String</span><span class="o">],</span>
    <span class="n">userStore</span><span class="k">:</span> <span class="kt">UserStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">User</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">user</span> <span class="k">=&gt;</span>
  <span class="n">userStore</span><span class="o">.</span><span class="n">save</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">producer</span><span class="o">.</span><span class="n">send</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;User $user persisted!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="nc">DuplicateEmail</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">Logger</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">error</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;Email ${user.email} already taken!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="nc">DuplicateUsername</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">Logger</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">error</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;Email ${user.email} already taken!&quot;</span><span class="o">)</span>
  <span class="o">}</span></code></pre></div> <p>After <code>flatMap</code>ping the result of <code>save</code>, we can pattern-match on the possible values. The nice thing here is that the Scala compiler checks for exhaustivity, so we never miss a declared error, in case that changes in the future.</p> <p>Sometimes, however, it happens that we are only interested in handling a subset of the errors, and whatever is added later should be handled at the top layers.</p> <p>Let’s say we only need to handle the <code>DuplicateEmail</code> error.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">mid2</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Logger:</span> <span class="kt">MonadThrow</span><span class="o">](</span>
    <span class="n">producer</span><span class="k">:</span> <span class="kt">Producer</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">String</span><span class="o">],</span>
    <span class="n">userStore</span><span class="k">:</span> <span class="kt">UserStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">User</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">DuplicateUsername</span>, <span class="kt">Unit</span><span class="o">]]</span> <span class="k">=</span> <span class="n">user</span> <span class="k">=&gt;</span>
  <span class="n">userStore</span><span class="o">.</span><span class="n">save</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">producer</span><span class="o">.</span><span class="n">send</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;User $user persisted!&quot;</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">asRight</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="nc">DuplicateEmail</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">Logger</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">error</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;Email ${user.email} already taken!&quot;</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">asRight</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">e</span><span class="o">.</span><span class="n">asLeft</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
  <span class="o">}</span></code></pre></div> <p>Any other error is caught in the last case, where we simply leave it unhandled.</p> <p>This works, though, the ergonomics are not the best, as we need to manually call <code>asRight</code> and <code>asLeft</code> in different places. We can improve the UX with some custom extension methods.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">mid3</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Logger:</span> <span class="kt">MonadThrow</span><span class="o">](</span>
    <span class="n">producer</span><span class="k">:</span> <span class="kt">Producer</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">String</span><span class="o">],</span>
    <span class="n">userStore</span><span class="k">:</span> <span class="kt">UserStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">User</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">DuplicateUsername</span>, <span class="kt">Unit</span><span class="o">]]</span> <span class="k">=</span> <span class="n">user</span> <span class="k">=&gt;</span>
  <span class="n">userStore</span>
    <span class="o">.</span><span class="n">save</span>
    <span class="o">.</span><span class="n">rethrow</span>
    <span class="o">.</span><span class="n">as</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;User $user persisted!&quot;</span><span class="o">)</span>
    <span class="o">.</span><span class="n">recoverErrorWith</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">DuplicateEmail</span> <span class="k">=&gt;</span>
        <span class="nc">Logger</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">error</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;Email ${user.email} already taken!&quot;</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="o">.</span><span class="n">lift</span></code></pre></div> <p>First of all, <code>rethrow</code> eliminates the inner <code>Either</code>, giving us <code>F[Unit]</code>. Next, we handle the error we are interested in via <code>recoverErrorWith</code>. Both functions are defined by <code>ApplicativeError</code>.</p> <p>Until here the resulting type remains <code>F[Unit]</code>. At last, the magic happens when we call <code>lift</code> and get <code>F[Either[DuplicateUsername, Unit]]</code> back!</p> <p>So what is <code>lift</code>? It is a custom extension method defined as follows.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">extension</span> <span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">MonadThrow</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="nd">@nowarn</span>
  <span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
    <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">asRight</span><span class="o">[</span><span class="kt">E</span><span class="o">]).</span><span class="n">recover</span> <span class="o">{</span> <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">asLeft</span> <span class="o">}</span></code></pre></div> <p>UPDATE: <a href="https://github.com/vasilmkd">Vasil Vasilev</a> discovered the existence of <code>attemptNarrow</code> from <code>ApplicativeError</code>, after having a quick chat about the differences between <code>lift</code> and <code>attempt</code>, which is exactly what this does.</p> <p>The only difference, is that <code>attemptNarrow</code> requires a <code>ClassTag</code>, but that’s not a problem :)</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable:</span> <span class="kt">ClassTag</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">fa</span><span class="o">.</span><span class="n">attemptNarrow</span></code></pre></div> <p>We could use <code>attemptNarrow</code> directly, but if you get to the end of this post, you’ll understand why I chose to keep the <code>lift</code> extension method instead.</p> <p>Notice that for this to work, we need to either declare the function’s return type or to indicate what types we expect when we call <code>lift</code>. E.g.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">f</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="nc">Err1</span><span class="o">)</span>

<span class="k">val</span> <span class="n">g</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Err1</span> <span class="kt">|</span> <span class="kt">Err2</span>, <span class="kt">Unit</span><span class="o">]]</span> <span class="k">=</span> <span class="n">f</span><span class="o">.</span><span class="n">lift</span>

<span class="k">val</span> <span class="n">h</span> <span class="k">=</span> <span class="n">f</span><span class="o">.</span><span class="n">lift</span><span class="o">[</span><span class="kt">Err1</span> <span class="kt">|</span> <span class="kt">Err2</span><span class="o">]</span>

<span class="n">g</span> <span class="o">&lt;-&gt;</span> <span class="n">h</span>
<span class="n">f</span> <span class="o">&lt;-&gt;</span> <span class="n">g</span><span class="o">.</span><span class="n">rethrow</span> <span class="o">&lt;-&gt;</span> <span class="n">h</span><span class="o">.</span><span class="n">rethrow</span></code></pre></div> <p>Here’s another way of doing the same without <code>rethrow</code> and <code>recoverErrorWith</code>.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">mid4</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Logger:</span> <span class="kt">MonadThrow</span><span class="o">](</span>
    <span class="n">producer</span><span class="k">:</span> <span class="kt">Producer</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">String</span><span class="o">],</span>
    <span class="n">userStore</span><span class="k">:</span> <span class="kt">UserStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">User</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">DuplicateUsername</span>, <span class="kt">Unit</span><span class="o">]]</span> <span class="k">=</span> <span class="n">user</span> <span class="k">=&gt;</span>
  <span class="n">userStore</span><span class="o">.</span><span class="n">save</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">producer</span><span class="o">.</span><span class="n">send</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;User $user persisted!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="nc">DuplicateEmail</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">Logger</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">error</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;Email ${user.email} already taken!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">e</span><span class="o">.</span><span class="n">raiseError</span>
  <span class="o">}.</span><span class="n">lift</span></code></pre></div> <p>The only problem with the technique used in both <code>mid3</code> and <code>mid4</code>, is that we lose the error type information after a partial error handling and lifting. For instance, if we add another error to <code>UserStore[F]#save</code>, the compiler won’t help us here.</p> <p>Nevertheless, this is easily fixed by pattern matching on all the errors, but it might require some repetition regarding <code>raiseError</code>.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">mid5</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Logger:</span> <span class="kt">MonadThrow</span><span class="o">](</span>
    <span class="n">producer</span><span class="k">:</span> <span class="kt">Producer</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">String</span><span class="o">],</span>
    <span class="n">userStore</span><span class="k">:</span> <span class="kt">UserStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">User</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">DuplicateUsername</span>, <span class="kt">Unit</span><span class="o">]]</span> <span class="k">=</span> <span class="n">user</span> <span class="k">=&gt;</span>
  <span class="n">userStore</span><span class="o">.</span><span class="n">save</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">producer</span><span class="o">.</span><span class="n">send</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;User $user persisted!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="nc">DuplicateEmail</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nc">Logger</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">error</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;Email ${user.email} already taken!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="nc">DuplicateUsername</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">e</span><span class="o">.</span><span class="n">raiseError</span>
  <span class="o">}.</span><span class="n">lift</span></code></pre></div> <p>If we add another <code>FooError</code> type in the bottom layers, the compiler is going to catch it here for us, and all we need to go is to re-raise it.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="nc">FooError</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="n">e</span><span class="o">.</span><span class="n">raiseError</span></code></pre></div> <p>That’s what I mean with the potential repetition regarding <code>raiseError</code>.</p> <p>To conclude with this mid-layer section, let’s just say that all of these error handling techniques are valid; only they have different trade-offs.</p> <h4 id="top-layer">Top layer</h4> <p>At the top layer, is where we either handle the error or we let it crash. So here’s the perfect place to use <code>rethrow</code> or <code>raiseError</code>s we don’t care about.</p> <p>In the following example, we do not care about any unhandled errors so we let it fail.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">top1</span><span class="o">(</span>
    <span class="n">consumer</span><span class="k">:</span> <span class="kt">Consumer</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">User</span><span class="o">],</span>
    <span class="n">mid</span><span class="k">:</span> <span class="kt">User</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">DuplicateUsername</span>, <span class="kt">Unit</span><span class="o">]]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">consumer</span><span class="o">.</span><span class="n">receive</span><span class="o">.</span><span class="n">evalMap</span> <span class="o">{</span> <span class="n">user</span> <span class="k">=&gt;</span>
    <span class="n">mid</span><span class="o">(</span><span class="n">user</span><span class="o">).</span><span class="n">rethrow</span> <span class="o">*&gt;</span> <span class="n">consumer</span><span class="o">.</span><span class="n">ack</span>
  <span class="o">}</span></code></pre></div> <p>If this is called by a library like Http4s, this will be translated into an HTTP response with code 500, for example.</p> <p>Or we could do something about it.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">top2</span><span class="o">(</span>
    <span class="n">consumer</span><span class="k">:</span> <span class="kt">Consumer</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">User</span><span class="o">],</span>
    <span class="n">mid</span><span class="k">:</span> <span class="kt">User</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">DuplicateUsername</span>, <span class="kt">Unit</span><span class="o">]]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">consumer</span><span class="o">.</span><span class="n">receive</span><span class="o">.</span><span class="n">evalMap</span> <span class="o">{</span> <span class="n">user</span> <span class="k">=&gt;</span>
    <span class="n">mid</span><span class="o">(</span><span class="n">user</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">consumer</span><span class="o">.</span><span class="n">ack</span>
      <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="nc">DuplicateUsername</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="o">(</span><span class="s">&quot;Duplicate username&quot;</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="n">consumer</span><span class="o">.</span><span class="n">ack</span>
    <span class="o">}.</span><span class="n">handlerErroWith</span> <span class="o">{</span> <span class="n">e</span> <span class="k">=&gt;</span>
      <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;Unhandled $e, let it crash?&quot;</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="n">consumer</span><span class="o">.</span><span class="n">nack</span>
    <span class="o">}</span>
  <span class="o">}</span></code></pre></div> <p>Any unhandled errors will be logged and unacked (negative acknowledge).</p> <h3 id="furthermore">Furthermore</h3> <p>At the beginning of the post, when the idea of using union types for error modelling was introduced, it was hinted that we could eliminate the <code>Either</code> altogether. How about that?</p> <p>Starting from the bottom layer, we can do this instead.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">UserStore</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="nc">:</span>
  <span class="k">def</span> <span class="n">fetch</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">UserId</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">DuplicateEmail</span> <span class="kt">|</span> <span class="kt">DuplicateUsername</span> <span class="kt">|</span> <span class="kt">Unit</span><span class="o">]</span></code></pre></div> <p>However, by doing so, we lose the <code>rethrow</code> ability, as we are no longer working with <code>Either</code>.</p> <p>Challenge accepted! Let’s introduce a <code>rethrowU</code> that works on union types.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">extension</span> <span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">MonadThrow</span>, <span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">E</span> <span class="kt">|</span> <span class="kt">A</span><span class="o">])</span>
  <span class="k">def</span> <span class="n">rethrowU</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">asEither</span><span class="o">).</span><span class="n">rethrow</span>

<span class="n">extension</span> <span class="o">[</span><span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">](</span><span class="n">ut</span><span class="k">:</span> <span class="kt">E</span> <span class="kt">|</span> <span class="kt">A</span><span class="o">)</span>
  <span class="nd">@nowarn</span>
  <span class="k">def</span> <span class="n">asEither</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">ut</span> <span class="k">match</span>
      <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
      <span class="k">case</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="o">)</span></code></pre></div> <p>In the same way, we can also introduce a <code>liftU</code>, defined in terms of <code>lift</code> under the same scope.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="n">extension</span> <span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">MonadThrow</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="k">def</span> <span class="n">liftU</span><span class="o">[</span><span class="kt">E</span> <span class="k">&lt;:</span> <span class="kt">Throwable:</span> <span class="kt">ClassTag</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">E</span> <span class="kt">|</span> <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">lift</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">asUnionType</span><span class="o">)</span>

<span class="n">extension</span> <span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">either</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">])</span>
  <span class="k">def</span> <span class="n">asUnionType</span><span class="k">:</span> <span class="kt">E</span> <span class="kt">|</span> <span class="kt">A</span> <span class="o">=</span>
    <span class="n">either</span> <span class="k">match</span>
      <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span>  <span class="k">=&gt;</span> <span class="n">e</span>
      <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span></code></pre></div> <p>This is the reason why I kept the <code>lift</code> extension method instead of using <code>attemptNarrow</code>. However, I could have also named this <code>attemptNarrowU</code> instead of <code>liftU</code>, but I prefer the shorter names :)</p> <p>Now we can rewrite the final <code>mid5</code> as follows.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">mid6</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Logger:</span> <span class="kt">MonadThrow</span><span class="o">](</span>
    <span class="n">producer</span><span class="k">:</span> <span class="kt">Producer</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">String</span><span class="o">],</span>
    <span class="n">userStore</span><span class="k">:</span> <span class="kt">UserStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">User</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">DuplicateUsername</span> <span class="kt">|</span> <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">user</span> <span class="k">=&gt;</span>
  <span class="n">userStore</span><span class="o">.</span><span class="n">save</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">()</span> <span class="k">=&gt;</span>
      <span class="n">producer</span><span class="o">.</span><span class="n">send</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;User $user persisted!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">DuplicateEmail</span> <span class="k">=&gt;</span>
      <span class="nc">Logger</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">error</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;Email ${user.email} already taken!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">DuplicateUsername</span> <span class="k">=&gt;</span>
      <span class="n">e</span><span class="o">.</span><span class="n">raiseError</span>
  <span class="o">}.</span><span class="n">liftU</span></code></pre></div> <p>And the final <code>top2</code> as shown below.</p> <div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span> <span class="n">top3</span><span class="o">(</span>
    <span class="n">consumer</span><span class="k">:</span> <span class="kt">Consumer</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">User</span><span class="o">],</span>
    <span class="n">mid</span><span class="k">:</span> <span class="kt">User</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">DuplicateUsername</span> <span class="kt">|</span> <span class="kt">Unit</span><span class="o">]</span>
<span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">consumer</span><span class="o">.</span><span class="n">receive</span><span class="o">.</span><span class="n">evalMap</span> <span class="o">{</span> <span class="n">user</span> <span class="k">=&gt;</span>
    <span class="n">mid</span><span class="o">(</span><span class="n">user</span><span class="o">).</span><span class="n">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">consumer</span><span class="o">.</span><span class="n">ack</span>
      <span class="k">case</span> <span class="nc">DuplicateUsername</span> <span class="k">=&gt;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warn</span><span class="o">(</span><span class="s">&quot;Duplicate username&quot;</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="n">consumer</span><span class="o">.</span><span class="n">ack</span>
    <span class="o">}.</span><span class="n">handlerErroWith</span> <span class="o">{</span> <span class="n">e</span> <span class="k">=&gt;</span>
      <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;Unhandled $e, let it crash?&quot;</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="n">consumer</span><span class="o">.</span><span class="n">nack</span>
    <span class="o">}</span>
  <span class="o">}</span></code></pre></div> <h3 id="conclusion">Conclusion</h3> <p>I think this error modeling and handling technique is very promising. I would probably still keep the <code>Either[E1 | E2, A</code>] model over <code>E1 | E2 | A</code>, but this blog post has demonstrated that both options are valid.</p> <p>The code shown in this post hasn’t been compiled, but I use the very same technique in the project of my <a href="https://leanpub.com/feda">upcoming book</a>, so you can have a look the <a href="https://github.com/gvolpe/trading/tree/main/modules/forecasts/src/main/scala/trading/forecasts">source code</a> directly.</p> <p>Let’s also remind ourselves that the left side of <code>Either</code> representing errors is merely a social agreement. We could as well do it the other way around, but that would need different <code>Functor</code> / <code>Monad</code> instances, so it is not quite practical.</p> <p>In the same way, we could agree that only the right hand-side type of a union type represents the successful value, and any other types on the left hand-side represent the errors. We could probably write typeclass instances that prove the lawfulness of such approach.</p> <p>Error handling is always a hot topic in FP land, so don’t take this as the <em>ultimate word</em>, but simply as a technique that can be exploited for our benefits :)</p> <p>Cheers, Gabriel.</p> <div class="post-categories"> <span class="post-meta"> <span class="post-date">Categories:</span> <a href="/blog/categories/#scala">scala</a> &nbsp; <a href="/blog/categories/#error-handling">error-handling</a> &nbsp; <a href="/blog/categories/#fp">fp</a> &nbsp; <a href="/blog/categories/#functional-programming">functional-programming</a> </span> </div> <aside class="share"> <span>Share this: </span> <a href="http://twitter.com/share?text=Scala 3: Error handling in FP land&amp;url=https://gvolpe.github.io/error-handling-scala3/&amp;hashtags=scala,haskell,fp&amp;via=volpegabriel87" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;"> <i class="fa fa-twitter-square"></i> </a> </aside> <div id="gh-comments"> <br/><br/> <h6>COMMENTS</h6> <div id="gh-comments-list"></div> </div> <script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script> <script src="/blog/js/github-comments.js"> </script> <script type="text/javascript"> DoGithubComments ( "gvolpe/blog" , "18" ); </script> <noscript>Please enable JavaScript to view comments.</noscript> </div> </article> <footer class="footer t-center"> <div class="container"> <div class="social-icons"> <ul class="text-left"> <li><a href="https://twitter.com/volpegabriel87" target="_blank"><i class="fa fa-twitter"></i></a></li> </ul> </div> <small>&copy; 2024 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small> <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small> </div> </footer> </main> </body> </html></body></html>
<!--
// # Zetsu Jekyll theme - https://github.com/nandomoreriame/zetsu/
// by nandomoreira.me
-->
