<!DOCTYPE html> <html lang="en-uk"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title> Parallel typeclass for Haskell &bull; gvolpe's blog </title> <meta name="description" content="As I’m preparing a talk about refinement types I will be giving this Thursday at the Functional Tricity Meetup, and I’ve recently given a similar talk using ..."> <link rel="stylesheet" href="/blog/css/main.css"> <link rel="canonical" href="https://gvolpe.github.io/blog/parallel-typeclass-for-haskell/"> <link rel="alternate" type="application/rss+xml" title="gvolpe's blog" href="https://gvolpe.github.io/blog/feed.xml" /> <!-- Global site tag (gtag.js) - Google Analytics --> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-142604198-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-142604198-1'); </script> <!-- -<script type="text/javascript"> -var _gaq = _gaq || []; -_gaq.push(['_setAccount', 'UA-142604198-1']); -_gaq.push(['_trackPageview']); - -(function() { - var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; - ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; - var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); -})(); -</script> --> </head> <body class="single"> <main class="main"> <header class="header"> <div class="overlay"> <div class="container"> <h1 class="title"> <a href="/blog/">gvolpe's blog</a> </h1> <nav class="navbar"> <a href="#" class="menu-icon"> <span></span> <span></span> <span></span> </a> <ul class="nav"> <li><a href="https://gvolpe.com" target="_blank">Website</a></li> </ul> </nav> </div> </div> </header> <article class="post container card"> <header class="post-header"> <h1 class="post-title">Parallel typeclass for Haskell</h1> <span class="post-meta"> <time class="post-date" datetime="2020-04-20">Apr 20, 2020</time> <span class="post-author">by Gabriel Volpe</span> </span> </header> <div class="post-content"> <p>As I’m preparing a talk about refinement types I will be giving this Thursday at the <a href="https://www.meetup.com/FunctionalTricity/events/269763842/">Functional Tricity Meetup</a>, and I’ve recently given a <a href="https://scala.love/gabriel-volpe-why-types-matter/">similar talk</a> using the Scala language as well, I realized there is a missing typeclass in Haskell.</p> <p>In the following sections, I will be providing examples and use cases for this typeclass to showcase why it would be great to have it in Haskell. Oh, yes… I love refinement types as well!</p> <p>In Haskell, we have the <a href="https://hackage.haskell.org/package/refined">refined</a> library and other more complex tools such as <a href="https://hackage.haskell.org/package/liquidhaskell">Liquid Haskell</a>.</p> <h3 id="refinement-types">Refinement types</h3> <p>Refinement types give us the ability to define validation rules, or more commonly called <em>predicates</em>, at the type level. This means we get compile-time validation whenever the values are known at compile-time.</p> <p>Say we have the following predicates and datatype:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Refined</span>

<span class="kr">type</span> <span class="kt">Age</span>  <span class="ow">=</span> <span class="kt">Refine</span> <span class="p">(</span><span class="kt">GreaterThan</span> <span class="mi">17</span><span class="p">)</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kt">Name</span> <span class="ow">=</span> <span class="kt">Refine</span> <span class="kt">NonEmpty</span> <span class="kt">Text</span>

<span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span>
  <span class="p">{</span> <span class="n">personAge</span> <span class="ow">::</span> <span class="kt">Age</span>
  <span class="p">,</span> <span class="n">personName</span> <span class="ow">::</span> <span class="kt">Name</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span></code></pre></div> <p>We can validate the creation of <code>Person</code> at compile-time using Template Haskell:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">me</span> <span class="ow">::</span> <span class="kt">Person</span>
<span class="nf">me</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="o">$$</span><span class="p">(</span><span class="n">refineTH</span> <span class="mi">32</span><span class="p">)</span> <span class="o">$$</span><span class="p">(</span><span class="n">refineTH</span> <span class="s">&quot;Gabriel&quot;</span><span class="p">)</span></code></pre></div> <p>If the age was a number under 18, or the name was an empty string, then our program wouldn’t compile. Isn’t that cool?</p> <p>Though, most of the time, we need to validate incoming data from external services, meaning <em>runtime validation</em>. Refined gives us a bunch of useful functions to achieve this, effectively replacing <em>smart constructors</em>. The most common one is defined as follows:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">refine</span> <span class="ow">::</span> <span class="kt">Predicate</span> <span class="n">p</span> <span class="n">x</span> <span class="ow">=&gt;</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">RefineException</span> <span class="p">(</span><span class="kt">Refined</span> <span class="n">p</span> <span class="n">x</span><span class="p">)</span></code></pre></div> <p>We can then use this function to validate our input data.</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">mkPerson</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">RefineException</span> <span class="kt">Person</span>
<span class="nf">mkPerson</span> <span class="n">a</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">age</span>  <span class="ow">&lt;-</span> <span class="n">refine</span> <span class="n">a</span>
  <span class="n">name</span> <span class="ow">&lt;-</span> <span class="n">refine</span> <span class="n">n</span>
  <span class="n">return</span> <span class="o">$</span> <span class="kt">Person</span> <span class="n">age</span> <span class="n">name</span></code></pre></div> <p>However, the program above will short-circuit on the first error, as any other Monad will do. It would be nice if we could validate all our inputs in parallel and accumulates errors, wouldn’t it?</p> <p>We can achieve this by converting our <code>Either</code> values given by <code>refine a</code> into <code>Validation</code>, use <code>Applicative</code> functions to compose the different parts, and finally converting back to <code>Either</code>.</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Data.Validation</span>

<span class="nf">mkPerson</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">RefineException</span> <span class="kt">Person</span>
<span class="nf">mkPerson</span> <span class="n">a</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">toEither</span> <span class="o">$</span> <span class="kt">Person</span>
  <span class="o">&lt;$&gt;</span> <span class="n">fromEither</span> <span class="p">(</span><span class="n">refine</span> <span class="n">a</span><span class="p">)</span>
  <span class="o">&lt;*&gt;</span> <span class="n">fromEither</span> <span class="p">(</span><span class="n">refine</span> <span class="n">n</span><span class="p">)</span></code></pre></div> <p>As we can see, it is a bit clunky, and this is a very repetitive task, which will only increase the amount of boilerplate in our codebase.</p> <p>This seems to be the <em>status quo</em> around validation in Haskell nowadays, and it was the same in Scala. So it’s kind of hard to realize we are missing what we don’t know: the <code>Parallel</code> typeclass. I didn’t know it was such a game changer until I started using it everywhere.</p> <p>This is exactly what this typeclass does for us in other languages, via its helpful functions and instances. Unfortunately, it doesn’t exist in Haskell, as far as I know… until now!</p> <h3 id="parallel-typeclass">Parallel typeclass</h3> <p>Let me introduce you to the <code>Parallel</code> typeclass, already present in <a href="https://pursuit.purescript.org/packages/purescript-parallel/4.0.0/docs/Control.Parallel.Class#t:Parallel">PureScript</a> and <a href="https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/Parallel.scala#L10">Scala</a>:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Control.Natural</span> <span class="p">((</span><span class="o">:~&gt;</span><span class="p">))</span>

<span class="kr">class</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Parallel</span> <span class="n">f</span> <span class="n">m</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">parallel</span> <span class="ow">::</span> <span class="n">m</span> <span class="kt">:~&gt;</span> <span class="n">f</span>
  <span class="n">sequential</span> <span class="ow">::</span> <span class="n">f</span> <span class="kt">:~&gt;</span> <span class="n">m</span></code></pre></div> <p>It defines a relationship between a <code>Monad</code> that can also be an <code>Applicative</code> with “parallely” behavior. That is, an <code>Applicative</code> instance that wouln’t pass the monadic laws.</p> <p>The most common relationship is the one given by <code>Either</code> and <code>Validation</code>. These two types are isomorphic, with the difference being that <code>Validation</code> has an <code>Applicative</code> instance that accumulate errors instead of short-circuiting on the first error.</p> <p>So we can represent this relationship via <em>natural transformation</em> in a <code>Parallel</code> instance:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Semigroup</span> <span class="n">e</span> <span class="ow">=&gt;</span> <span class="kt">Parallel</span> <span class="p">(</span><span class="kt">Validation</span> <span class="n">e</span><span class="p">)</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">parallel</span>   <span class="ow">=</span> <span class="kt">NT</span> <span class="n">fromEither</span>
  <span class="n">sequential</span> <span class="ow">=</span> <span class="kt">NT</span> <span class="n">toEither</span></code></pre></div> <p>In the same way, we can represent the relationship between <code>[]</code> and <code>ZipList</code>:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Parallel</span> <span class="kt">ZipList</span> <span class="kt">[]</span> <span class="kr">where</span>
  <span class="n">parallel</span>   <span class="ow">=</span> <span class="kt">NT</span> <span class="kt">ZipList</span>
  <span class="n">sequential</span> <span class="ow">=</span> <span class="kt">NT</span> <span class="n">getZipList</span></code></pre></div> <p>Now, all this ceremony only becomes useful if we define some functions based on <code>Parallel</code>. One of the most common ones is <code>parMapN</code> (or <code>parMap2</code> in this case, but ideally, it should be abstracted over its arity).</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">parMapN</span>
  <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">,</span> <span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Parallel</span> <span class="n">f</span> <span class="n">m</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a0</span>
  <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a1</span>
  <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a0</span> <span class="ow">-&gt;</span> <span class="n">a1</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span>
  <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">parMapN</span> <span class="n">ma0</span> <span class="n">ma1</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">unwrapNT</span> <span class="n">sequential</span>
  <span class="p">(</span><span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">unwrapNT</span> <span class="n">parallel</span> <span class="n">ma0</span> <span class="o">&lt;*&gt;</span> <span class="n">unwrapNT</span> <span class="n">parallel</span> <span class="n">ma1</span><span class="p">)</span></code></pre></div> <p>Before we get to see how we can leverage this function with refinement types and data validation, we will define a type alias for our effect type and a function <code>ref</code>, which will convert <code>RefineException</code>s into a <code>[Text]</code>, since our error type needs to be a <code>Semigroup</code>.</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Control.Arrow</span> <span class="p">(</span><span class="nf">left</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Text</span>     <span class="p">(</span><span class="nf">pack</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Refined</span>

<span class="kr">type</span> <span class="kt">Eff</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Either</span> <span class="p">[</span><span class="kt">Text</span><span class="p">]</span> <span class="n">a</span>

<span class="nf">ref</span> <span class="ow">::</span> <span class="kt">Predicate</span> <span class="n">p</span> <span class="n">x</span> <span class="ow">=&gt;</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="p">(</span><span class="kt">Refined</span> <span class="n">p</span> <span class="n">x</span><span class="p">)</span>
<span class="nf">ref</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">left</span> <span class="p">(</span><span class="nf">\</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">pack</span> <span class="o">$</span> <span class="n">show</span> <span class="n">e</span><span class="p">])</span> <span class="p">(</span><span class="n">refine</span> <span class="n">x</span><span class="p">)</span></code></pre></div> <p>In the example below, we can appreciate how this function can be used to create a <code>Person</code> instance with validated input data (it’s a breeze):</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">mkPerson</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Text</span> <span class="ow">-&gt;</span> <span class="kt">Eff</span> <span class="kt">Person</span>
<span class="nf">mkPerson</span> <span class="n">a</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">parMapN</span> <span class="p">(</span><span class="n">ref</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">ref</span> <span class="n">n</span><span class="p">)</span> <span class="kt">Person</span></code></pre></div> <p>Our <code>mkPerson</code> is now validating all our inputs in parallel via an implicit round-trip <code>Either</code>/<code>Validation</code> given by our <code>Parallel</code> instance.</p> <p>We can also use <code>parMapN</code> to use a different <code>Applicative</code> instance for lists without manually wrapping / unwrapping <code>ZipList</code>s.</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">n1</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">n2</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>

<span class="nf">n3</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">n3</span> <span class="ow">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">n1</span> <span class="o">&lt;*&gt;</span> <span class="n">n2</span>

<span class="nf">n4</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">n4</span> <span class="ow">=</span> <span class="n">parMapN</span> <span class="n">n1</span> <span class="n">n2</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span></code></pre></div> <p>Without <code>Parallel</code>’s simplicity, it would look as follows:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">n4</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">n4</span> <span class="ow">=</span> <span class="n">getZipList</span> <span class="o">$</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="kt">ZipList</span> <span class="n">n1</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="n">n2</span></code></pre></div> <p>For convenience, here’s another function we can define in terms of <code>parMapN</code>:</p> <div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">parTupled</span>
  <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">,</span> <span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Parallel</span> <span class="n">f</span> <span class="n">m</span><span class="p">)</span>
  <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a0</span>
  <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a1</span>
  <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a0</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
<span class="nf">parTupled</span> <span class="n">ma0</span> <span class="n">ma1</span> <span class="ow">=</span> <span class="n">parMapN</span> <span class="n">ma0</span> <span class="n">ma1</span> <span class="p">(,)</span></code></pre></div> <p>In Scala, there’s also an instance for <code>IO</code> and <code>IO.Par</code>, a newtype that provides a different <code>Applicative</code> instance, which allows us to use functions such as <code>parMapN</code> with <code>IO</code> computations to run them in parallel!</p> <p>And this is only the beginning… There are so many other useful functions we could define!</p> <p>For now, the code is presented in <a href="https://github.com/gvolpe/types-matter">this Github repository</a> together with some other examples. Should there be enough interest, I might polish it and ship it as a library.</p> <p>Let me know your thoughts!</p> <p>Gabriel.</p> <aside class="share"> <span>Share this: </span> <a href="http://twitter.com/share?text=Parallel typeclass for Haskell&amp;url=https://gvolpe.github.io/parallel-typeclass-for-haskell/&amp;hashtags=scala,haskell,fp&amp;via=volpegabriel87" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;"> <i class="fa fa-twitter-square"></i> </a> </aside> </div> </article> <footer class="footer t-center"> <div class="container"> <div class="social-icons"> <ul class="text-left"> <li><a href="https://twitter.com/volpegabriel87" target="_blank"><i class="fa fa-twitter"></i></a></li> </ul> </div> <small>&copy; 2022 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small> <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small> </div> </footer> </main> </body> </html></body></html>
<!--
// # Zetsu Jekyll theme - https://github.com/nandomoreriame/zetsu/
// by nandomoreira.me
-->
